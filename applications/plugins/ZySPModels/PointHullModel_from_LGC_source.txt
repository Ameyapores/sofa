#include "LGCPointModel.h"
#include "LGCObbModel.h"

#include <sofa/component/loader/MeshObjLoader.h>
#include <sofa/component/topology/MeshTopology.h>

#include <cuda.h>
#include <cuda_runtime.h>
#include <cuda_runtime_api.h>

#include <cutil/cutil.h>

#include <hacd/hacdCircularList.h>
#include <hacd/hacdVector.h>
#include <hacd/hacdICHull.h>
#include <hacd/hacdGraph.h>
#include <hacd/hacdHACD.h>

#include "LGCObbDrawable.h"
#include "LGCPlane3.h"

namespace sofa
{
    namespace component
    {
        namespace collision
        {
            SOFA_DECL_CLASS(LGCPointModel)

            int LGCPointModelClass = core::RegisterObject("Surface point model for LGC")
            .add< LGCPointModel >()
            .addAlias("LGCSurfacePoints")
            ;
        }
    }
}

using namespace sofa::component::collision;

LGCPoint::LGCPoint(LGCPointModel *model, int index):
    core::TCollisionElementIterator<LGCPointModel>(model, index)
{
    std::cout <<  "LGCPoint::LGCPoint(" << model->getName() << "," << index << "), constructed via (model,index)" << std::endl;
    _point = model->surfacePoint(index);
    _translation = model->position();
    _orientation = model->orientation();
}

LGCPoint::LGCPoint(core::CollisionElementIterator &i):
                   TCollisionElementIterator<LGCPointModel>(static_cast<LGCPointModel*>(i.getCollisionModel()), i.getIndex())
{
    std::cout << "LGCPoint::LGCPoint(" << i.getCollisionModel()->getName() << "," << i.getIndex() << "), constructed via CollisionElementIterator" << std::endl;
    LGCPointModel* model = static_cast<LGCPointModel*>(i.getCollisionModel());
    _point = model->surfacePoint(i.getIndex());
    _translation = model->position();
    _orientation = model->orientation();
}

LGCPointPatch::LGCPointPatch(LGCPointModel *model, int index):
    TCollisionElementIterator<LGCPointModel>(model, index)
{
    if (model)
    {
        // std::cout <<  "LGCPointPatch::LGCPointPatch(" << model->getName() << "," << index << "), constructed via (model,index)" << std::endl;
        _cluster = model->childCluster(index);

        if (model->numChildClusters() == 0)
            _cluster = model->parentCluster();
    }
}

LGCPointPatch::LGCPointPatch(core::CollisionElementIterator &i):
    TCollisionElementIterator<LGCPointModel>(static_cast<LGCPointModel*>(i.getCollisionModel()), i.getIndex())
{
    // std::cout << "LGCPointPatch::LGCPointPatch(" << i.getCollisionModel()->getName() << "," << i.getIndex() << "), constructed via CollisionElementIterator" << std::endl;
    LGCPointModel* model = static_cast<LGCPointModel*>(i.getCollisionModel());
    _cluster = model->childCluster(i.getIndex());

    if (model->numChildClusters() == 0)
        _cluster = model->parentCluster();

    /*std::cout << " _cluster == " << _cluster  << std::endl;
    if (_cluster)
        std::cout << *_cluster << std::endl;*/
}

LGCPointModelFace::LGCPointModelFace(LGCPointModel *model, int index):
    TCollisionElementIterator<LGCPointModel>(model, index)
{
    LGCPointCluster<Vec3Types>* cluster = model->childCluster(index);
    if (cluster)
    {
        _minFacetIndex = cluster->minFacetRange();
        _maxFacetIndex = cluster->maxFacetRange();
    }
    else
        _minFacetIndex = _maxFacetIndex = -1;
}

LGCPointModelFace::LGCPointModelFace(core::CollisionElementIterator &i):
    TCollisionElementIterator<LGCPointModel>(static_cast<LGCPointModel*>(i.getCollisionModel()), i.getIndex())
{
    LGCPointModel* model = static_cast<LGCPointModel*>(i.getCollisionModel());
    LGCPointCluster<Vec3Types>* cluster = model->childCluster(i.getIndex());
    if (cluster)
    {
        _minFacetIndex = cluster->minFacetRange();
        _maxFacetIndex = cluster->maxFacetRange();
    }
    else
        _minFacetIndex = _maxFacetIndex = -1;
}

LGCPointModel::LGCPointModel(): _pointCluster(NULL),
                                _cubeModel(NULL),
                                _hacd(NULL),
                                _hacdHeapManager(NULL),
                                _surfacePointsDrawListValid(false),
                                _showSurfacePoints(initData(&_showSurfacePoints, false, "showSurfacePoints", "Show surface point shell including auxiliary points")),
                                _drawOcTree(initData(&_drawOcTree, true, "drawOcTree", "Draw point cloud's associated octree")),
                                _drawOcTreeVerbose(initData(&_drawOcTreeVerbose, true, "drawOcTreeVerbose", "Draw point cloud colored after octree leaf association")),
                                _drawKdTree(initData(&_drawKdTree, false, "drawKdTree", "Draw point cloud's associated k-d-Tree")),
                                _computeOctree(initData(&_computeOctree, true, "computeOctree", "Compute OcTree for point cloud")),
                                _computeKdTree(initData(&_computeKdTree, false, "computeKdTree", "Compute k-d-Tree for point cloud")),
                                _drawObbPlanes(initData(&_drawObbPlanes, false, "drawObbPlanes", "Show cluster OBB planes")),
                                _edgePointsPerEdge(initData(&_edgePointsPerEdge, 5, "edgePointsPerEdge", "Number of points to compute per model edge")),
                                _showOBBTreeStructure(initData(&_showOBBTreeStructure, true, "showOBBTreeStructure", "Show model's OBB tree structure")),
                                _showOBBVolumes(initData(&_showOBBVolumes, true, "showOBBVolumes", "Show model's OBB volumes")),
                                _doSegmentation(initData(&_doSegmentation, false, "doSegmentation", "Apply PCL segmentation to model")),
                                _minDrawLimit(initData(&_minDrawLimit, -1, "minDrawLimit", "Minimum OBB tree level to draw", true, false)),
                                _maxDrawLimit(initData(&_maxDrawLimit, -1, "maxDrawLimit", "Maximum OBB tree level to draw", true, false)),
                                _pointGrids(initData(&_pointGrids, "pointGrids", "bitmask'ed occupancy of surface point grids per face")),
                                // _faceNormals(initData(&_faceNormals, "faceNormals", "Face normals of collision mesh")),
                                // _faceCentroids(initData(&_faceCentroids, "faceCentroids", "Centroids of faces in collision mesh")),
                                _pointGridOrigins(initData(&_pointGridOrigins,"pointGridOrigins", "Point mask origins per face")),
                                _pointGridSizeX(initData(&_pointGridSizeX,"pointGridSizeX", "Point mask grid size (X direction)")),
                                _pointGridSizeY(initData(&_pointGridSizeY,"pointGridSizeY", "Point mask grid size (Y direction)")),
                                _pointGridDimensions(initData(&_pointGridDimensions,"pointGridDimensions", "Point mask dimensions per face"))
                                //_pointGridDiagonals(initData(&_pointGridDiagonals,"pointGridDiagonals", "Point mask diagonals per face"))
{
    _pointGrids.setGroup("Witness grid");
    //_pointGridDiagonals.setGroup("Witness grid");
    _pointGridOrigins.setGroup("Witness grid");
    _pointGridSizeX.setGroup("Witness grid");
    _pointGridSizeY.setGroup("Witness grid");

    _computeOctree.setGroup("Space partitioning");
    _computeKdTree.setGroup("Space partitioning");
}

LGCPointModel::~LGCPointModel()
{
    std::cout << "LGCPointModel::~LGCPointModel(" << this->getName() << ")" << std::endl;

    if (_hacd && _hacdHeapManager)
    {
        HACD::DestroyHACD(_hacd);
        HACD::releaseHeapManager(_hacdHeapManager);
    }

    if (_pointCluster)
    {
        delete _pointCluster;
        std::cout << "_pointCluster deleted" << std::endl;
    }

    if (_computeSurfacePoints.getValue() && _surfacePoints.size() > 0)
    {
        for(std::vector<Vector3*>::iterator it = _surfacePoints.begin(); it != _surfacePoints.end(); it++)
        {
            delete *it;
            *it = NULL;
        }
        _surfacePoints.clear();
        std::cout << "_surfacePoints vector deleted and cleared" << std::endl;
    }

    if (_edgePoints.size() > 0)
    {
        for(std::vector<Vector3*>::iterator it = _edgePoints.begin(); it != _edgePoints.end(); it++)
        {
            delete *it;
            *it = NULL;
        }
        _edgePoints.clear();
        std::cout << "_edgePoints vector deleted and cleared" << std::endl;
    }

#if 0
    std::vector<sofa::component::collision::LGCPointModel* > pmV;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::collision::LGCPointModel,std::vector<sofa::component::collision::LGCPointModel* > > cbP(&pmV);
    getContext()->getObjects(TClassInfo<sofa::component::collision::LGCObbModel>::get(), cbP, TagSet(),BaseContext::SearchUp);

    std::vector<sofa::component::collision::LGCObbModel* > omV;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::collision::LGCObbModel,std::vector<sofa::component::collision::LGCObbModel* > > cbO(&omV);
    getContext()->getObjects(TClassInfo<sofa::component::collision::LGCObbModel>::get(), cbO, TagSet(),BaseContext::SearchUp);
    std::cout << "Found LGCObbModels: " << omV.size() << std::endl;
    std::cout << "Found LGCPointModels: " << pmV.size() << std::endl;

    if (omV.size() == 0 && pmV.size() == 0)
    {
        cudaError err = ::cudaDeviceReset();
        if (cudaSuccess != err)
        {
            std::cerr << "Cuda error in file '" << __FILE__ << "' in line " << __LINE__ << ": " << cudaGetErrorString(err) << std::endl;
        }
        else
        {
            std::cout << " cudaDeviceReset() called" << std::endl;
        }
    }
#endif
}

std::pair<sofa::core::CollisionElementIterator,sofa::core::CollisionElementIterator> LGCPointModel::getInternalChildren(int index) const
{
    f_printLog.setValue(true);
    sout << "LGCPointModel::getInternalChildren(" << index << ")" << sendl;
    if (index == 0)
    {
        if (this->numChildClusters() > 0)
        {
            //sout << " index 0 = " << this->childCluster(0)->getName() << ", last = " << this->childCluster(this->numChildClusters()-1)->getName() << sendl;
            sout << " return LGCPointPatch(" << 1 << ") -- LGCPointPatch(" << this->numChildClusters() << ")" << " for point cluster " << _pointCluster->getName() << sendl;
            return std::make_pair(LGCPointPatch(this, 1), LGCPointPatch(this, this->numChildClusters()));
        }
        else
        {
            sout << " return empty iterators (Root cluster without children)" << sendl;
            return CollisionModel::getInternalChildren(index);
        }
    }
//    else if (index < _pointCluster->numChildren())
//    {
//        std::cout << " return FAKE: LGCPointPatch(" << index << ") -- LGCPointPatch(" << index << ")" << std::endl;
//        return std::make_pair(LGCPointPatch(this, index), LGCPointPatch(this, index /*+ 1*/));
//    }
    else
    {
        sout << " return empty iterators: child cluster has no further children" << sendl;
        return CollisionModel::getInternalChildren(index);
    }
}

std::pair<sofa::core::CollisionElementIterator,sofa::core::CollisionElementIterator> LGCPointModel::getExternalChildren(int index) const
{
    f_printLog.setValue(true);
    sout << "LGCPointModel::getExternalChildren(" << index << ")" << sendl;
    if (index >= 0 && index < _pointCluster->numChildren())
    {
        if (this->numChildClusters() > 0)
        {
            if (index == 0)
            {
                sout << " return empty iterators: root cluster has no faces when children exist" << sendl;
                return CollisionModel::getExternalChildren(index);

            }
            sout << " return LGCPointModelFace(" << _pointCluster->childCluster(index)->minFacetRange() << ") -- LGCPointModelFace(" << _pointCluster->childCluster(index)->maxFacetRange() << ")" << sendl;
            return std::make_pair(LGCPointModelFace(this, _pointCluster->childCluster(index)->minFacetRange()),
                                  LGCPointModelFace(this, _pointCluster->childCluster(index)->maxFacetRange()));
        }
        else
        {
            sout << " return LGCPointModelFace(" << _pointCluster->minFacetRange() << ") -- LGCPointModelFace(" << _pointCluster->maxFacetRange() << ")" << sendl;
            return std::make_pair(LGCPointModelFace(this, _pointCluster->minFacetRange()),
                                  LGCPointModelFace(this, _pointCluster->maxFacetRange()));
        }
    }
    else
    {
        /*if (index == 0)
        {
            sout << " return LGCPointModelFace(" << _pointCluster->minFacetRange() << ") -- LGCPointModelFace(" << _pointCluster->maxFacetRange() << ")" << sendl;
            return std::make_pair(LGCPointModelFace(this, _pointCluster->minFacetRange()),
                                  LGCPointModelFace(this, _pointCluster->maxFacetRange()));
        }
        else*/
        {
            sout << " return empty iterators: index " << index << " outside cluster range" << sendl;
            return CollisionModel::getExternalChildren(index);
        }
    }
}

unsigned long LGCPointModel::numSurfacePoints() const
{
    return _pointCluster->numSurfacePoints();
}

Vector3 LGCPointModel::surfacePoint(const unsigned long & idx) const
{
    if (idx < _pointCluster->numSurfacePoints())
        return _pointCluster->surfacePoint(idx);

    return Vector3(DBL_MAX, DBL_MAX, DBL_MAX);
}

unsigned long LGCPointModel::numEdgePoints() const
{
    return _pointCluster->numEdgePoints();
}

Vector3 LGCPointModel::edgePoint(const unsigned long & idx) const
{
    if (idx < _pointCluster->numEdgePoints())
        return _pointCluster->edgePoint(idx);

    return Vector3(DBL_MAX, DBL_MAX, DBL_MAX);
}

LGCPointCluster<Vec3Types>* LGCPointModel::childCluster(const unsigned long& idx, bool withoutParent)
{
    if (!withoutParent)
    {
        if (idx == 0)
            return _pointCluster;
        else if (idx > 0 && idx < _pointCluster->numChildren())
            return _pointCluster->childCluster(idx - 1);
    }
    else
    {
        if (idx > 0 && idx < _pointCluster->numChildren())
            return _pointCluster->childCluster(idx);
    }

    return NULL;
}

void LGCPointModel::init()
{
    std::cout << "LGCPointModel::init(" << getName() << ")" << std::endl;
    std::vector<sofa::component::collision::LGCObbModel* > omV;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::collision::LGCObbModel,std::vector<sofa::component::collision::LGCObbModel* > > cb(&omV);

    std::cout << "Looking for an accompanying LGCObbModel." << std::endl;

    std::vector<sofa::component::loader::MeshObjLoader* > molV;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::loader::MeshObjLoader,std::vector<sofa::component::loader::MeshObjLoader* > > mol_cb(&molV);

    if (getContext() && getContext()->getRootContext())
    {
        getContext()->getObjects(TClassInfo<sofa::component::loader::MeshObjLoader>::get(), mol_cb, TagSet(),BaseContext::SearchDown);
        std::cout << "MeshOBJLoader objects found: " << molV.size() << std::endl;
        for (std::vector<sofa::component::loader::MeshObjLoader*>::iterator it = molV.begin(); it != molV.end(); it++)
        {
            std::cout << " * OBJ loader: " << (*it)->getName() << std::endl;
            BaseData* fnData = (*it)->findField("filename");
            if (fnData)
            {
                const void* txtValue = fnData->getValueVoidPtr();
                _fileName = fnData->getValueTypeInfo()->getTextValue(txtValue, 0);
                std::cout << "       File name: " << _fileName << std::endl;

                bool fileFound = sofa::helper::system::DataRepository.findFile(_fileName);
                std::string absFilePath;
                if (fileFound)
                {
                    absFilePath = sofa::helper::system::DataRepository.getFile(_fileName);
                    std::cout << "       File absolute path: " << absFilePath << std::endl;
                }
                else
                {
                    std::cerr << "       ERROR: Failed to resolve absolute path of " << _fileName << std::endl;
                }

                //_fileName = sofa::helper::system::DataRepository.getFirstPath() + "/" + _fileName;
                std::cout << "       Absolute path: " << _fileName << std::endl;
            }
        }

        bool doBaseInit = true;

        getContext()->getObjects(TClassInfo<sofa::component::collision::LGCObbModel>::get(), cb, TagSet(),BaseContext::SearchUp);
        std::cout << "Found LGCObbModels: " << omV.size() << std::endl;
        for (std::vector<sofa::component::collision::LGCObbModel*>::iterator omIt = omV.begin(); omIt != omV.end(); omIt++)
        {
            if ((*omIt)->initDone())
            {
                std::cout << " init already done for model " << (*omIt)->getName() << std::endl;
                if ((*omIt)->fileName().compare(_fileName) == 0)
                {
                    doBaseInit = false;
                    LGCCollisionModel::copyModelData(*omIt);
                    break;
                }
            }
        }

        if (this->_computeSurfacePoints.getValue())
            setComputationHints((LGCCollisionModel::ComputationHints)(LGCCollisionModel::COMPUTE_FACET_SURFACE_POINTS|LGCCollisionModel::COMPUTE_FACET_SURFACE_AREAS));

        if (doBaseInit)
        {
            LGCCollisionModel::init();
        }
        else
        {
            LGCCollisionModel::updateData();
        }
        CollisionModel::init();
    }

    _pointCluster = new LGCPointCluster<Vec3Types>(_position, _orientation, NULL, this);
    _pointCluster->setName(getName() + " PointCluster");

    if (_useOriginalMesh.getValue())
    {
        std::cout << " using original mesh" << std::endl;
        _model = _modelBuilder->getModel("Standard mesh");
    }
    else
    {
        std::cout << " using pre-processed mesh" << std::endl;
        _model = _modelBuilder->getModel("Polyhedron with point shell");
    }
    std::cout << " Using polyhedron model named: " << _model.name() << std::endl;
    _modelToDraw = _model;

    //if (this->_computeSurfacePoints.getValue())
    {
        if (!_model.isComputed(Exact_Polyhedron_3::POLYHEDRON_SURFACE_POINTS))
        {
            _model.setComputationHints((Exact_Polyhedron_3::ComputationFlags)(Exact_Polyhedron_3::POLYHEDRON_DEFAULT_COMPUTATION_FLAGS | Exact_Polyhedron_3::POLYHEDRON_SURFACE_POINTS));
            _model.updateData();
#if 0
            _model.evaluateSurfacePoints();
#endif
        }
    }

    /// Achtung: Init-Methode operiert auf Geometrie im Koordinatenursprung;
    /// buildPointCluster() und fitObbs() erwarten/benutzen dementsprechend dieselbe Transformationsvorschrift;
    /// OBB- und Drawable-Klassen transformieren die berechneten Hüllkörper eigenständig an die richtigen Weltkoordinaten.

    createWitnessGrid();

    buildPointCluster();

    buildConvexDecomposition();

    if (_pointCluster->writePCDFile(getName()))
    {
        _pointCluster->setDoSegmentation(_doSegmentation.getValue());
        _pointCluster->readFromPCD();

        _pointCluster->setOriginalModelPtr(&_model);
        _pointCluster->buildChildHierarchy();

        validateClusterStructure();

        _pointCluster->fitObbs();

        //if (_pointCluster->numChildren() > 0)
        //    _pointCluster->childCluster(0)->clusterObb()->obbDrawable().setColor(Vec<4,Real>(1,1,0,1));

        // Only visible when checked for collision;
        //_pointCluster->clusterObb()->setVisible(false);

        _pointCluster->adjustFacetIndices();

        _pointCluster->buildPQPModel();

        if (_computeOctree.getValue())
        {
            _pointCluster->setComputeOcTree(true);
        }

        if (_computeKdTree.getValue())
        {
            _pointCluster->setComputeKdTree(true);
        }

        this->resize(_pointCluster->numChildren() + 1);

        buildDrawList();
    }
}

void LGCPointModel::cleanup()
{
    std::cout << "LGCPointModel::cleanup(" << this->getName() << ")" << std::endl;
}

float triangleArea2D(const Vector3& x, const Vector3& y)
{
    return (x.x() - x.y()) * (y.y() - y.z()) - (x.y() - x.z()) * (y.x() - y.y());
}

void barycentricCoordinates(const Vector3& p, const Vector3 &t1, const Vector3 &t2, const Vector3 &t3, float& u, float& v, float& w)
{
    Vector3 m = (t2 - t1).cross(t3 - t1);
    float nu, nv, ood;
    float x = std::fabs(m.x()), y = std::fabs(m.y()), z = std::fabs(m.z());
    if (x >= y && x >= z)
    {
        nu = triangleArea2D(Vector3(p.y(), p.z(), t2.y()), Vector3(t2.z(), t3.y(), t3.z()));
        nv = triangleArea2D(Vector3(p.y(), p.z(), t3.y()), Vector3(t3.z(), t1.y(), t1.z()));
        ood = 1.0f / m.x();
    }
    else if (y >= x && y >= z)
    {
        nu = triangleArea2D(Vector3(p.x(), p.z(), t2.x()), Vector3(t2.z(), t3.x(), t3.z()));
        nv = triangleArea2D(Vector3(p.x(), p.z(), t3.x()), Vector3(t3.z(), t1.x(), t1.z()));
        ood = 1.0f / -m.y();
    }
    else
    {
        nu = triangleArea2D(Vector3(p.x(), p.y(), t2.x()), Vector3(t2.y(), t3.x(), t3.y()));
        nv = triangleArea2D(Vector3(p.x(), p.y(), t3.x()), Vector3(t3.y(), t1.x(), t1.y()));
        ood = 1.0f / m.z();
    }

    u = nu * ood;
    v = nv * ood;
    w = 1.0f - u - v;
}

bool triangleIsCCW(const Vector3 &t1, const Vector3 &t2, const Vector3 &t3, const Vector3& n)
{
    Vector3 c1(t1.x() - t2.x(), t1.y() - t2.y(), t1.z() - t2.z());
    Vector3 c2(t1.x() - t3.x(), t1.y() - t3.y(), t1.z() - t3.z());

    c1 = c1.cross(c2);

    return (n * c1) > sofa::helper::kEpsilon;
}
#if 0
// For processed triangles; processed means: counter-clockwise vertex order
bool pointResidesInTriangle(const Vector3 &p, const Vector3 &t1, const Vector3 &t2, const Vector3 &t3, bool degenerate = false)
{
#if 0
    float u, v, w;
    barycentricCoordinates(p, t1, t2, t3, u, v, w);
    return (v >= sofa::helper::kEpsilon && w >= sofa::helper::kEpsilon && (v + w) <= 1.0f);

#else

    Vector3 v0;
    Vector3 v1;
    Vector3 v2;

    v0 = t2 - t1;
    v1 = t3 - t1;
    v2 = p - t1;

    double d00 = v0 * v0;
    double d01 = v0 * v1;
    double d11 = v1 * v1;
    double d20 = v2 * v0;
    double d21 = v2 * v1;
    double denom = d00 * d11 - d01 * d01;

    double v = (d11 * d20 - d01 * d21) / denom;
    double w = (d00 * d21 - d01 * d20) / denom;

    std::cout << "    v = " << v << ", w = " << w << ", v+w = " << (v+w) << std::endl;

    if (v >= 0.0f && w >= 0.0f && (v+w) <= 1.0f)
        return true;

    return false;
#endif
}
#endif

bool SameSide(Vector3 p1, Vector3 p2, Vector3 A, Vector3 B)
{
    Vector3 cp1 = (B - A).cross(p1 - A);
    Vector3 cp2 = (B - A).cross(p2 - A);

    if (cp1 * cp2 >= 0.0f)
        return true;
    return false;
}

bool pointResidesInTriangle(Vector3 P, Vector3 t1, Vector3 t2, Vector3 t3)
{
    Vector3 A = t1, B = t2, C = t3;
    if (SameSide(P, A, B, C) && SameSide(P, B, A, C) && SameSide(P, C, A, B))
    {
        //Vector3 vc1 = Vector3.Cross(Vector3.Subtract(A, B), Vector3.Subtract(A, C));
        Vector3 vc1 = (A - B).cross(A - C);
        float vc2 = (A - P) * vc1;

        if (std::fabs(vc2) <= .01f)
            return true;
    }

    return false;
}


#define DEBUG_OBB_TRANSFORMS
// #define DEBUG_SURFACE_POINTS
// #define DEBUG_LGCPOINTMODEL_SURFACE_MASKS
#define DEBUG_LGCPOINTMODEL_SURFACE_MASKS_FROM_DATA
void LGCPointModel::draw(const core::visual::VisualParams *vparams)
{
    double sfTransform[16];
    _orientation.writeOpenGlMatrix(sfTransform);
    sfTransform[12] = _position.x();
    sfTransform[13] = _position.y();
    sfTransform[14] = _position.z();
    sfTransform[15] = 1;

    if (vparams->displayFlags().getShowCollisionModels())
    {
        LGCCollisionModel::draw(vparams);
#if 0
        if (_surfacePointsDrawListValid)
        {
            glPushMatrix();
            glPushAttrib(GL_ENABLE_BIT);

            glEnable(GL_LIGHTING);
            glEnable(GL_COLOR_MATERIAL);

            glMultMatrixd(sfTransform);
            glCallList(_surfacePointsGLList);

            glPopAttrib();
            glPopMatrix();
        }
#endif
    }

    if (vparams->displayFlags().getShowBoundingCollisionModels())
    {
        if (_pointCluster->showOcTree() != _drawOcTree.getValue())
            _pointCluster->setShowOcTree(_drawOcTree.getValue());

        if (_pointCluster->showOcTreeVerbose() != _drawOcTreeVerbose.getValue())
            _pointCluster->setShowOcTreeVerbose(_drawOcTreeVerbose.getValue());

        if (_pointCluster->showKdTree() != _drawKdTree.getValue())
            _pointCluster->setShowKdTree(_drawKdTree.getValue());

        if (_pointCluster->drawVerbose() != _showInternalCollisionModels.getValue())
            _pointCluster->setDrawVerbose(_showInternalCollisionModels.getValue());

        if (_pointCluster->showObbPlanes() != _drawObbPlanes.getValue())
            _pointCluster->setShowObbPlanes(_drawObbPlanes.getValue());

        if (_pointCluster->drawOBBTreeStructure() != _showOBBTreeStructure.getValue())
            _pointCluster->setDrawOBBTreeStructure(_showOBBTreeStructure.getValue());

        if (_pointCluster->drawOBBVolumes() != _showOBBVolumes.getValue())
            _pointCluster->setDrawOBBVolumes(_showOBBVolumes.getValue());

        _pointCluster->setDrawLimits(_minDrawLimit.getValue(), _maxDrawLimit.getValue());

        _pointCluster->draw(vparams);

        if (_drawCubeModel.getValue() && _cubeModel != NULL)
            _cubeModel->draw(vparams);

        {
            sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);
            if (meshTopology)
            {
                glPushMatrix();
                glPushAttrib(GL_ENABLE_BIT);

                glEnable(GL_LIGHTING);
                glEnable(GL_COLOR_MATERIAL);

                //glMultMatrixd(sfTransform);

                glLineWidth(4.0f);

                // std::cout << " draw: " << _pointCluster->numChildren() << " child clusters" << std::endl;
                ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));
                for (int k = 0; k < _pointCluster->numChildren(); k++)
                {
                    LGCPointCluster<Vec3Types>* childCluster = _pointCluster->childCluster(k);
                    const sofa::helper::vector<std::pair<unsigned int, sofa::component::topology::BaseMeshTopology::Triangle> >& clusterTriangles = childCluster->getTriangleIndices();

                    // std::cout << "  " << childCluster->getName() << " tri count: " << clusterTriangles.size() << std::endl;
                    for (int l = 0; l < clusterTriangles.size(); l++)
                    {
                        Vector3 pt0 = meshPoints[clusterTriangles[l].second[0]];
                        Vector3 pt1 = meshPoints[clusterTriangles[l].second[1]];
                        Vector3 pt2 = meshPoints[clusterTriangles[l].second[2]];

                        // std::cout << "   " << clusterTriangles[l][0] << "," << clusterTriangles[l][1] << "," << clusterTriangles[l][2] << ": " << pt0 << "," << pt1 << "," << pt2 << std::endl;
                        glBegin(GL_LINES);
                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), 0.8);
                        glVertex3d(pt0.x(), pt0.y(), pt0.z());
                        glVertex3d(pt1.x(), pt1.y(), pt1.z());
                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), 0.8);
                        glVertex3d(pt1.x(), pt1.y(), pt1.z());
                        glVertex3d(pt2.x(), pt2.y(), pt2.z());
                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), 0.8);
                        glVertex3d(pt2.x(), pt2.y(), pt2.z());
                        glVertex3d(pt0.x(), pt0.y(), pt0.z());
                        glEnd();
                    }
                }

                glLineWidth(1.0f);
                glPopAttrib();
                glPopMatrix();
            }
        }
#ifdef LGC_POINT_MODEL_DRAW_HACD_CLUSTERS
        {
            glPushMatrix();
            glPushAttrib(GL_ENABLE_BIT);

            glEnable(GL_LIGHTING);
            glEnable(GL_COLOR_MATERIAL);

            glLineWidth(1.5f);
            for (int i = 0; i < _hacd->GetNClusters(); i++)
            {
                //if (i % 2 == 1)
                {
                    size_t nPoints = _hacd->GetNPointsCH(i);
                    size_t nTriangles = _hacd->GetNTrianglesCH(i);

                    HACD::Vec3<HACD::Real> * chPoints = new HACD::Vec3<HACD::Real>[nPoints];
                    HACD::Vec3<long> * chTriangles = new HACD::Vec3<long>[nTriangles];
                    _hacd->GetCH(i, chPoints, chTriangles);
                    LGCPointCluster<Vec3Types>* childCluster = _pointCluster->childCluster(i);

                    for (int j = 0; j < nTriangles; j++)
                    {
                        HACD::Vec3<HACD::Real> h0 = chPoints[chTriangles[j].X()];
                        HACD::Vec3<HACD::Real> h1 = chPoints[chTriangles[j].Y()];
                        HACD::Vec3<HACD::Real> h2 = chPoints[chTriangles[j].Z()];

                        glBegin(GL_LINES);

                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), childCluster->getClusterColor().w());

                        glVertex3d(h0.X(), h0.Y(), h0.Z());
                        glVertex3d(h1.X(), h1.Y(), h1.Z());

                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), childCluster->getClusterColor().w());

                        glVertex3d(h1.X(), h1.Y(), h1.Z());
                        glVertex3d(h2.X(), h2.Y(), h2.Z());

                        glColor4d(childCluster->getClusterColor().x(), childCluster->getClusterColor().y(), childCluster->getClusterColor().z(), childCluster->getClusterColor().w());

                        glVertex3d(h2.X(), h2.Y(), h2.Z());
                        glVertex3d(h0.X(), h0.Y(), h0.Z());
                        glEnd();
                    }

                    delete[] chPoints;
                    delete[] chTriangles;
                }
            }

            glLineWidth(1.0f);
            glPopAttrib();
            glPopMatrix();

            for (int i = 0; i < _pointCluster->numChildren(); i++)
            {
                LGCPointCluster<Vec3Types>* childCluster = _pointCluster->childCluster(i);
                std::cout << " draw cvPlanes of " << childCluster->getName() << ": " << childCluster->_cvPlaneDrawables.size() << std::endl;
                for (int j = 0; j < childCluster->_cvPlaneDrawables.size(); j++)
                    childCluster->_cvPlaneDrawables[j].draw(vparams, childCluster->getClusterColor());
            }
        }
#endif

#ifdef DEBUG_OBB_TRANSFORMS
        vparams->drawTool()->drawArrow(Vector3(0,0,0), this->position(), 0.03f, Vec4f(1,0,0,0.5));
        Vector3 orientedObbCenter = this->position() + this->orientation().rotate(_pointCluster->clusterObb()->center());
        vparams->drawTool()->drawArrow(this->position(), orientedObbCenter, 0.03f, Vec4f(0,1,0,0.5));

        Vector3 he = _pointCluster->clusterObb()->halfExtents();
        Vector3 heTransform = orientedObbCenter;

        Vector3 tc0 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), he.y(), he.z()));
        Vector3 tc7 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), -he.y(), -he.z()));

        vparams->drawTool()->drawArrow(orientedObbCenter, tc0, 0.015f, Vec4f(0,0,1,0.5));
        vparams->drawTool()->drawArrow(orientedObbCenter, tc7, 0.015f, Vec4f(0,0,1,0.5));

        for (unsigned int i = 0; i < _pointCluster->clusterObb()->numOBBChildren(); i++)
        {
            LGCObb<Vec3Types>* obb =  _pointCluster->clusterObb()->child(i);
            Vector3 rotatedChildOffset = this->orientation().rotate(obb->lcData()._childOffset);

            vparams->drawTool()->drawArrow(this->position(), /*orientedObbCenter + */ this->position() + rotatedChildOffset, 0.01f, Vec4f(1,0,1,0.5));

            Vector3 childHe = _pointCluster->clusterObb()->child(i)->halfExtents();

            Vector3 tc0 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), childHe.y(), childHe.z()));
            Vector3 tc7 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() *  Vector3(-childHe.x(), -childHe.y(), -childHe.z()));

            vparams->drawTool()->drawArrow(this->position() + rotatedChildOffset, tc0, 0.01f, Vec4f(0,0,1,0.5));
            vparams->drawTool()->drawArrow(this->position() + rotatedChildOffset, tc7, 0.01f, Vec4f(0,0,1,0.5));
        }
#endif // DEBUG_OBB_TRANSFORMS

/// WARNING: This list is not transformed; points will remain at initial model location
#ifdef DEBUG_SURFACE_POINTS
        // std::cout << "Debug surface points: " << _model.size_of_facets() << " facets." << std::endl;
        std::vector<Vector3> insideSurfacePoints;
        std::vector<Vector3> edgeSurfacePoints;
        std::vector<Vector3> outsideSurfacePoints;
        std::vector<Vector3> originPoints;

        for (Exact_Polyhedron_3::Facet_iterator it =  _model.facets_begin();
                                                      it != _model.facets_end();
                                                      it++)
        {
            // std::cout << " surface grid size for facet " << facetCounter++ << ": " << it->numSurfacePointsX() << " x " << it->numSurfacePointsY() << std::endl;
            if (it->is_triangle())
            {
#if 0
                originPoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(0,0).x()),
                                               CGAL::to_double(it->surfacePoint(0,0).y()),
                                               CGAL::to_double(it->surfacePoint(0,0).z())));

                originPoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(0,1).x()),
                                               CGAL::to_double(it->surfacePoint(0,1).y()),
                                               CGAL::to_double(it->surfacePoint(0,1).z())));

                originPoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(1,0).x()),
                                               CGAL::to_double(it->surfacePoint(1,0).y()),
                                               CGAL::to_double(it->surfacePoint(1,0).z())));

                originPoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(1,1).x()),
                                               CGAL::to_double(it->surfacePoint(1,1).y()),
                                               CGAL::to_double(it->surfacePoint(1,1).z())));

                Vector3 p0(CGAL::to_double(it->surfacePoint(0,0).x()),
                           CGAL::to_double(it->surfacePoint(0,0).y()),
                           CGAL::to_double(it->surfacePoint(0,0).z()));

                Vector3 p3(CGAL::to_double(it->surfacePoint(1,1).x()),
                           CGAL::to_double(it->surfacePoint(1,1).y()),
                           CGAL::to_double(it->surfacePoint(1,1).z()));

                vparams->drawTool()->drawArrow(p0, p3, 0.02f, Vec4f(0,0,1,0.33));
#endif
                for (unsigned long i = 0; i <= it->numSurfacePointsX(); i++)
                {
                    for (unsigned long j = 0; j <= it->numSurfacePointsY(); j++)
                    {
                        if (it->surfacePointType(i,j,true) == INSIDE_SURFACE)
                        {
                            insideSurfacePoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(i,j).x()),
                                                            CGAL::to_double(it->surfacePoint(i,j).y()),
                                                            CGAL::to_double(it->surfacePoint(i,j).z())));
                        }
                        else if (it->surfacePointType(i,j,true) == EDGE_OF_SURFACE)
                        {
                            edgeSurfacePoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(i,j).x()),
                                                            CGAL::to_double(it->surfacePoint(i,j).y()),
                                                            CGAL::to_double(it->surfacePoint(i,j).z())));
                        }
                        else if (it->surfacePointType(i,j,true) == OUTSIDE_SURFACE)
                        {
                            outsideSurfacePoints.push_back(Vector3(CGAL::to_double(it->surfacePoint(i,j).x()),
                                                            CGAL::to_double(it->surfacePoint(i,j).y()),
                                                            CGAL::to_double(it->surfacePoint(i,j).z())));
                        }
                    }
                }
            }
        }

        if (insideSurfacePoints.size() > 0)
        {
            vparams->drawTool()->drawSpheres(insideSurfacePoints, 0.01f, Vec4f(0,1,0,0.33));
        }
        if (edgeSurfacePoints.size() > 0)
        {
            vparams->drawTool()->drawSpheres(edgeSurfacePoints, 0.01f, Vec4f(1,1,0,0.33));
        }
        if (outsideSurfacePoints.size() > 0)
        {
            vparams->drawTool()->drawSpheres(outsideSurfacePoints, 0.01f, Vec4f(1,0,0,0.33));
        }
        if (originPoints.size() > 0)
        {
            vparams->drawTool()->drawSpheres(originPoints, 0.03f, Vec4f(0,0,1,0.33));
        }
#endif //DEBUG_SURFACE_POINTS

#ifdef DEBUG_LGCPOINTMODEL_SURFACE_MASKS
        sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);
        if (meshTopology)
        {
            //std::cout << "LGCCollisionModelBase::_mState = " << LGCCollisionModelBase::_mState->getName() << std::endl;
            sofa::component::topology::MeshTopology::SeqTriangles triangles = meshTopology->getTriangles();
            ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));
            ReadAccessor<Data<VecPointMask> > surfacePoints(_pointGrids);
            //ReadAccessor<Data<vector<Vector3> > > centroids(_faceCentroids);
            ReadAccessor<Data<VecPointMaskOrigin> > gridOrigins(_pointGridOrigins);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeX(_pointGridSizeX);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeY(_pointGridSizeY);
            if (surfacePoints.size() > 0)
            {
                //unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
                //unsigned int tilesPerSide = std::sqrt(numTiles);

                Matrix3 modelRotation;
                LGCTransformable<Real>::_orientation.toMatrix(modelRotation);

                Matrix4 modelOrientation; modelOrientation.identity();
                for (int i = 0; i < 3; i++)
                    for (int j = 0; j < 3; j++)
                        modelOrientation(i,j) = modelRotation(i,j);

                Exact_Polyhedron_3::Facet_const_iterator fit = _model.facets_begin();
                for (unsigned long k = 0; k < surfacePoints.size(); k++)
                {
                    if (k < triangles.size())
                    {
                        Vector3 corner0 = meshPoints[triangles[k][0]];
                        Vector3 corner1 = meshPoints[triangles[k][1]];
                        Vector3 corner2 = meshPoints[triangles[k][2]];

                        // std::cout << "corners: " << corner0 << "," << corner1 << "," << corner2 << std::endl;

                        glPushMatrix();

                        Vector3 corner0Offset = corner0 - this->_position;
                        Vector3 gridOriginOffset = gridOrigins[k];
                        Vector3 gridStepX = gridSizeX[k];
                        Vector3 gridStepY = gridSizeY[k];

                        Vector3 gridPt1 = this->_position;
                        Vector3 gridPt15 = gridPt1 + corner0Offset;
                        Vector3 gridPt2 = gridPt15 + modelOrientation.transform(gridOriginOffset);
                        Vector3 gridPt3 = gridPt2 + modelOrientation.transform(gridStepX);
                        Vector3 gridPt4 = gridPt3 - modelOrientation.transform(gridStepY);

                        glLineWidth(5.0f);
                        glBegin(GL_LINES);
                        glColor4d(0, 0.9, 0, 0.5);
                        glVertex3d(0,0,0);
                        glVertex3d(gridPt1.x(), gridPt1.y(), gridPt1.z());
                        glColor4d(0, 0, 0.9, 0.5);
                        glVertex3d(gridPt1.x(), gridPt1.y(), gridPt1.z());
                        glVertex3d(gridPt15.x(), gridPt15.y(), gridPt15.z());
                        glVertex3d(gridPt15.x(), gridPt15.y(), gridPt15.z());
                        glColor4d(0.9, 0.9, 0, 0.5);
                        glVertex3d(gridPt2.x(), gridPt2.y(), gridPt2.z());
                        glColor4d(0, 0.9, 0.9, 0.5);
                        glVertex3d(gridPt2.x(), gridPt2.y(), gridPt2.z());
                        glVertex3d(gridPt3.x(), gridPt3.y(), gridPt3.z());
                        glColor4d(0.9, 0.9, 0.9, 0.5);
                        glVertex3d(gridPt3.x(), gridPt3.y(), gridPt3.z());
                        glVertex3d(gridPt4.x(), gridPt4.y(), gridPt4.z());
                        glEnd();

                        glPointSize(3.0);
                        glBegin(GL_POINTS);
                        for (unsigned int p = 0; p <= fit->numSurfacePointsX(); p++)
                        {
                            for (unsigned int q = 0; q <= fit->numSurfacePointsY(); q++)
                            {
                                Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                                if (pointResidesInTriangle(gp, corner0, corner1, corner2))
                                {
                                    glColor4d(0, 0.9, 0, 0.5);
                                }
                                else
                                {
                                    glColor4d(0.9, 0, 0, 0.5);
                                }
                                glVertex3d(gp.x(), gp.y(), gp.z());
                            }
                        }
                        glEnd();

                        glPointSize(1.0f);
                        glLineWidth(1.0f);
                        glPopMatrix();
                    }
                    fit++;
                }
            }
        }
#endif //DEBUG_LGCPOINTMODEL_SURFACE_MASKS
#ifdef DEBUG_LGCPOINTMODEL_SURFACE_MASKS_FROM_DATA
        if (_showSurfacePoints.getValue())
        {
            sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);
            if (meshTopology)
            {
                //std::cout << "LGCCollisionModelBase::_mState = " << LGCCollisionModelBase::_mState->getName() << std::endl;
                sofa::component::topology::MeshTopology::SeqTriangles triangles = meshTopology->getTriangles();
                ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));
                ReadAccessor<Data<VecPointMask> > surfacePoints(_pointGrids);
                ReadAccessor<Data<VecPointMaskOrigin> > gridOrigins(_pointGridOrigins);
                ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeX(_pointGridSizeX);
                ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeY(_pointGridSizeY);

                unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
                unsigned int tilesPerSide = std::sqrt(numTiles);
                unsigned int pmSize = tilesPerSide * LGC_POINT_MODEL_GRID_TILE_SIZE;

                Matrix3 modelRotation;
                LGCTransformable<Real>::_orientation.toMatrix(modelRotation);

                Matrix4 modelOrientation; modelOrientation.identity();
                for (int i = 0; i < 3; i++)
                    for (int j = 0; j < 3; j++)
                        modelOrientation(i,j) = modelRotation(i,j);

                glPushMatrix();

                glPointSize(3.0);
                glBegin(GL_POINTS);
                for (unsigned long k = 0; k < surfacePoints.size(); k++)
                {
                    Vector3 corner0 = meshPoints[triangles[k][0]];
                    Vector3 corner0Offset = corner0 - this->_position;
                    Vector3 gridOriginOffset = gridOrigins[k];
                    Vector3 gridStepX = gridSizeX[k];
                    Vector3 gridStepY = gridSizeY[k];

                    Vector3 gridPt1 = this->_position;
                    Vector3 gridPt15 = gridPt1 + corner0Offset;
                    Vector3 gridPt2 = gridPt15 + modelOrientation.transform(gridOriginOffset);

                    for (unsigned int p = 0; p < pmSize; p++)
                    {
                        for (unsigned int q = 0; q < pmSize; q++)
                        {
                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = q;
                            else
                                tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                            unsigned long shift = (unsigned long) (pow(2, targetedBit));

                            if (surfacePoints[k][tilesPerSide * tileX + tileY] & shift)
                            {
                                Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));

                                if (tileX == 0 && tileY == 0)
                                    glColor4d(0.9, 0.9, 0, 0.5);
                                else if (tileX == 0 && tileY == 1)
                                    glColor4d(0, 0.9, 0.9, 0.5);
                                else if (tileX == 1 && tileY == 0)
                                    glColor4d(0.9, 0, 0.9, 0.5);
                                else if (tileX == 1 && tileY == 1)
                                    glColor4d(0.9, 0.9, 0.9, 0.5);

                                glVertex3d(gp.x(), gp.y(), gp.z());
                            }
                        }
                    }
                }
                glEnd();
                glPopMatrix();
            }
        }
#endif //DEBUG_LGCPOINTMODEL_SURFACE_MASKS_FROM_DATA
    }
}

void LGCPointModel::buildDrawList()
{
    std::cout << "LGCPointModel::buildDrawList(): Polyhedron with " << _model.size_of_facets() << " facets." << std::endl;
    /*unsigned long fIdx = 0;
    for (Exact_Polyhedron_3::Facet_iterator it =  _model.facets_begin();
                                                  it != _model.facets_end();
                                                  it++)
    {
        std::cout << " == Point mask facet " << fIdx++ << " == " << std::endl;
        for (unsigned long i = 0; i <= it->numSurfacePointsX(); i++)
        {
            std::cout << i << ": ";
            for (unsigned long j = 0; j <= it->numSurfacePointsY(); j++)
            {

                if (it->surfacePointType(i,j) == INSIDE_SURFACE)
                {
                    _surfacePoints.push_back(new Vector3(CGAL::to_double(it->surfacePoint(i,j).x()),
                                                    CGAL::to_double(it->surfacePoint(i,j).y()),
                                                    CGAL::to_double(it->surfacePoint(i,j).z())));
                    std::cout << "1 ";
                }
                else
                    std::cout << "0 ";
            }
            std::cout << std::endl;
        }
    }*/

    for (unsigned long i = 0; i < _pointCluster->numEdgePoints(); i++)
        _edgePoints.push_back(new Vector3(_pointCluster->edgePoint(i).x(),
                                          _pointCluster->edgePoint(i).y(),
                                          _pointCluster->edgePoint(i).z()));

    double sfTransform[16];
    _orientation.inverse().writeOpenGlMatrix(sfTransform);

    _surfacePointsGLList = glGenLists(1);
    if (_surfacePointsGLList == 0)
    {
        GLenum errCode = glGetError();
        if (errCode != GL_NO_ERROR)
        {
#ifdef USE_GLU_ERROR_STRING
       const GLubyte *errString = gluErrorString(errCode);
       std::cerr << "OpenGL Error: " << errString << std::endl;
#else
        std::cerr << "OpenGL error: " << errCode << std::endl;
#endif
        }
    }
    else
    {
        _surfacePointsDrawListValid = true;

        std::cout << "Surface points GL list ID: " << _surfacePointsGLList << std::endl;
        glNewList(_surfacePointsGLList, GL_COMPILE);

        GLfloat pointSize;
        glGetFloatv(GL_POINT_SIZE, &pointSize);

        glPushMatrix();
        glPushAttrib(GL_ENABLE_BIT);

        glDisable(GL_LIGHTING);
        glEnable(GL_COLOR_MATERIAL);

        glPointSize(1.5f);
        std::cout << "Surface points count check: " << _surfacePoints.size() << std::endl;
        glMultMatrixd(sfTransform);
        glTranslated(-_position.x(), -_position.y(), -_position.z());
        glBegin(GL_POINTS);
        for (unsigned long k = 0; k < _surfacePoints.size(); k++)
        {
            glColor4f(1.0f, 0.0f, 0.0f, 0.25f);
            Vector3 vtx = *(_surfacePoints[k]);
            glVertex3d(vtx.x(), vtx.y(), vtx.z());
        }

        for (unsigned long k = 0; k < _edgePoints.size(); k++)
        {
            glColor4f(0.0f, 1.0f, 0.0f, 0.25f);
            Vector3 vtx = *(_edgePoints[k]);
            glVertex3d(vtx.x(), vtx.y(), vtx.z());
        }
        glEnd();

        glPointSize(pointSize);
        glEnable(GL_LIGHTING);

        glPopAttrib();
        glPopMatrix();
        glEndList();
    }

    _pointCluster->buildClusterDrawList();
}

void LGCPointModel::buildPointCluster()
{
    std::cout << "=== LGCPointModel::buildPointCluster(" << getName() << ") ===" << std::endl;

    if (_pointCluster != NULL)
    {
#ifdef LGC_POINT_MODEL_BUILD_CLUSTER_FROM_CGAL
        std::cout << " Facets to process: " << _model.size_of_facets() << std::endl;
        unsigned long edgePtIdx = 0;
        unsigned long vertexIdx = 0;
        for (Exact_Polyhedron_3::Facet_iterator it = _model.facets_begin(); it != _model.facets_end(); it++)
        {
            typename Exact_Polyhedron_3::Facet::Halfedge_around_facet_circulator
                                    he_circ = it->facet_begin(),
                                    he_circ_end(he_circ);
            // std::cout << "  * Facet: " << it->index() << std::endl;
            do
            {
                Exact_Polyhedron_3::Point_3 pt = he_circ->vertex()->point();
                Vector3 vtx(CGAL::to_double(pt.x()),
                            CGAL::to_double(pt.y()),
                            CGAL::to_double(pt.z()));

                Exact_Polyhedron_3::Point_3 npt = he_circ->next()->vertex()->point();
                Vector3 nvtx(CGAL::to_double(npt.x()),
                             CGAL::to_double(npt.y()),
                             CGAL::to_double(npt.z()));

                if (_pointCluster->addVertex(vtx, vertexIdx, it->index()))
                    vertexIdx++;

                for (unsigned int p = 0; p < _edgePointsPerEdge.getValue(); p++)
                {
                    // double edgeFrac = (edgeLen / _edgePointsPerEdge.getValue()) * (1.0f * p);
                    Vector3 ep = vtx + ((nvtx - vtx) * (1.0f * p / _edgePointsPerEdge.getValue()));
                    // std::cout << " " << edgeFrac << "/" << edgeLen << ": " << ep << std::endl;
                    if (_pointCluster->addEdgePoint(ep, edgePtIdx, he_circ->index(), (unsigned long) it->index()))
                    {
                        if (he_circ->opposite() != Exact_Polyhedron_3::Halfedge_handle() &&
                            he_circ->opposite()->facet() != Exact_Polyhedron_3::Facet_handle())

                            _pointCluster->setEdgePointFacetIndex(edgePtIdx, he_circ->opposite()->facet()->index());

                        edgePtIdx++;
                    }
                    // std::cout << "  * " << p << ": point " << ep  << "/edge index " << he_circ->index() << "/facet index " << (unsigned long) it->index() << std::endl;
                }

            } while (++he_circ != he_circ_end);

            if (this->_computeSurfacePoints.getValue())
            {
                std::cout << " Add surface points for facet " << it->index() << ": " << it->numSurfacePointsX() << "x" << it->numSurfacePointsY() << std::endl;
                for (unsigned long r = 0; r < it->numSurfacePointsX(); r++)
                {
                    for (unsigned long s = 0; s < it->numSurfacePointsY(); s++)
                    {
                        if (it->surfacePointType(r,s) == INSIDE_SURFACE)
                        {
                            Vector3 pt(CGAL::to_double(it->surfacePoint(r,s).x()),
                                       CGAL::to_double(it->surfacePoint(r,s).y()),
                                       CGAL::to_double(it->surfacePoint(r,s).z()));
                            _pointCluster->addSurfacePoint(pt, r * it->numSurfacePointsX() + s, (unsigned long) it->index());
                            std::cout << " * " << r << "," << s << ": " << pt << "/" << (unsigned long) it->index() << std::endl;
                        }
                    }
                }
            }
            else
            {
                std::cout << " Add surface points for facet " << it->index() << ": Centroid as placeholder." << std::endl;

                Vector3 pt(CGAL::to_double(it->centroid().x()),
                           CGAL::to_double(it->centroid().y()),
                           CGAL::to_double(it->centroid().z()));
                _pointCluster->addSurfacePoint(pt, 0, (unsigned long) it->index());
                std::cout << " * 0: " << pt << "/" << (unsigned long) it->index() << std::endl;
            }
        }
#else
        sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);

        if (meshTopology != NULL && _model.size_of_facets() > 0)
        {
            Matrix3 modelRotation;
            LGCTransformable<Real>::_orientation.toMatrix(modelRotation);

            Matrix4 modelOrientation; modelOrientation.identity();
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    modelOrientation(i,j) = modelRotation(i,j);

            sofa::component::topology::MeshTopology::SeqTriangles triangles = meshTopology->getTriangles();
            ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));

            ReadAccessor<Data<VecPointMask> > surfacePoints(_pointGrids);
            ReadAccessor<Data<VecPointMaskOrigin> > gridOrigins(_pointGridOrigins);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeX(_pointGridSizeX);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeY(_pointGridSizeY);

            unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
            unsigned int tilesPerSide = std::sqrt(numTiles);
            unsigned int pmSize = tilesPerSide * LGC_POINT_MODEL_GRID_TILE_SIZE;

            unsigned long facetIndex = 0;
            unsigned long edgePtIdx = 0;
            unsigned long vertexIdx = 0;

            std::cout << " Faces in model: " << _model.size_of_facets() << std::endl;
            for (Exact_Polyhedron_3::Facet_iterator it = _model.facets_begin(); it != _model.facets_end(); it++)
            {
                Vector3 corner0 = meshPoints[triangles[facetIndex][0]];
                Vector3 corner1 = meshPoints[triangles[facetIndex][1]];
                Vector3 corner2 = meshPoints[triangles[facetIndex][2]];

                // std::cout << "  Facet " << facetIndex << ": corners before transform: " << corner0 << "," << corner1 << "," << corner2 << std::endl;

                corner0 = modelOrientation.transform(corner0);
                corner0 += position();
                corner1 = modelOrientation.transform(corner1);
                corner1 += position();
                corner2 = modelOrientation.transform(corner2);
                corner2 += position();

                // std::cout << "  Facet " << facetIndex << ": corners after transform: " << corner0 << "," << corner1 << "," << corner2 << std::endl;

                if (_pointCluster->addVertex(corner0, vertexIdx, it->index()))
                    vertexIdx++;

                if (_pointCluster->addVertex(corner1, vertexIdx, it->index()))
                    vertexIdx++;

                if (_pointCluster->addVertex(corner2, vertexIdx, it->index()))
                    vertexIdx++;


                typename Exact_Polyhedron_3::Facet::Halfedge_around_facet_circulator
                                        he_circ = it->facet_begin(),
                                        he_circ_end(he_circ);
                unsigned int edgeCount = 0;
                do
                {
                    Vector3 vtx, nvtx;
                    if (edgeCount == 0)
                    {
                        vtx = corner0;
                        nvtx = corner1;
                    }
                    else if (edgeCount == 1)
                    {
                        vtx = corner1;
                        nvtx = corner2;
                    }
                    else if (edgeCount == 2)
                    {
                        vtx = corner2;
                        nvtx = corner0;
                    }


                    for (unsigned int p = 0; p < _edgePointsPerEdge.getValue(); p++)
                    {
                        Vector3 ep = vtx + ((nvtx - vtx) * (1.0f * p / _edgePointsPerEdge.getValue()));
                        if (_pointCluster->addEdgePoint(ep, edgePtIdx, he_circ->index(), (unsigned long) it->index()))
                        {
                            if (he_circ->opposite() != Exact_Polyhedron_3::Halfedge_handle() &&
                                he_circ->opposite()->facet() != Exact_Polyhedron_3::Facet_handle())

                                _pointCluster->setEdgePointFacetIndex(edgePtIdx, he_circ->opposite()->facet()->index());

                            edgePtIdx++;
                        }
                        // std::cout << "  * " << p << ": point " << ep  << "/edge index " << he_circ->index() << "/facet index " << (unsigned long) it->index() << std::endl;
                    }
                    edgeCount++;

                } while (++he_circ != he_circ_end);
#if 0
                Vector3 corner0Offset = corner0 - this->_position;
                Vector3 gridOriginOffset = gridOrigins[facetIndex];
                Vector3 gridStepX = gridSizeX[facetIndex];
                Vector3 gridStepY = gridSizeY[facetIndex];

                Vector3 gridPt1 = this->_position;
                Vector3 gridPt15 = gridPt1 + corner0Offset;
                Vector3 gridPt2 = gridPt15 + modelOrientation.transform(gridOriginOffset);

                unsigned long numSurfacePts = 0;
                for (unsigned int p = 0; p < pmSize; p++)
                {
                    for (unsigned int q = 0; q < pmSize; q++)
                    {
                        unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                        unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxX = 0;
                        if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxX = p;
                        else
                            tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxY = 0;
                        if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxY = q;
                        else
                            tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                        unsigned long shift = (unsigned long) (pow(2, targetedBit));

                        if (surfacePoints[facetIndex][tilesPerSide * tileX + tileY] & shift)
                        {
                            Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                            _pointCluster->addSurfacePoint(gp, p * it->numSurfacePointsX() + q, (unsigned long) it->index());
                            numSurfacePts++;
                        }
                    }
                }

                if (numSurfacePts == 0)
                {
                    std::cerr << " WARNING: Surface point calculation failure (degenerate case, cause unknown); placing centroid as replacement" << std::endl;
                    Vector3 triCentroid((corner0.x() + corner1.x() + corner2.x()) / 3.0f,
                                        (corner0.y() + corner1.y() + corner2.y()) / 3.0f,
                                        (corner0.z() + corner1.z() + corner2.z()) / 3.0f);

                    _pointCluster->addSurfacePoint(triCentroid, 0, (unsigned long) it->index());
                }
#endif
                facetIndex++;
            }
        }
#endif
    }
    std::cout << "Point cluster count for " << getName() << ": " << _pointCluster->numEdgePoints() + _pointCluster->numSurfacePoints() + _pointCluster->numVertices() << std::endl;
}

void LGCPointModel::validateClusterStructure()
{
    std::cout << "=== LGCPointModel::validateClusterStructure(" << getName() << ") BEGIN ===" << std::endl;
    std::cout << " cluster child count: " << _pointCluster->numChildren() << std::endl;
    std::cout << " vertices: " << _pointCluster->numVertices() << ", edge points: " << _pointCluster->numEdgePoints() << ", surface points: " << _pointCluster->numSurfacePoints() << std::endl;

    if (_pointCluster->numChildren() > 0)
    {
        for (unsigned long i = 0; i < _pointCluster->numChildren() + 1; i++)
        {
            LGCPointCluster<Vec3Types>* childCluster;
            if (i == 0)
                childCluster = _pointCluster;
            else
                childCluster = _pointCluster->childCluster(i - 1);
            std::cout << " ==== validate child cluster " << i << " ====" << std::endl;
            std::cout << "  vertices: " << childCluster->numVertices() << ", edge points: " << childCluster->numEdgePoints() << ", surface points: " << childCluster->numSurfacePoints() << std::endl;

            std::vector<unsigned long> touchedFacets;
            for (unsigned long k = 0; k < childCluster->numSurfacePoints(); k++)
            {
                if (std::find(touchedFacets.begin(), touchedFacets.end(), childCluster->surfacePointFacetIndex(k)) == touchedFacets.end())
                    touchedFacets.push_back(childCluster->surfacePointFacetIndex(k));
            }

            std::cout << "  touched facets: " << touchedFacets.size() << " --";
            for (std::vector<unsigned long>::const_iterator fit = touchedFacets.begin(); fit != touchedFacets.end(); fit++)
                std::cout << " " << *fit;

            std::cout << std::endl;

            /// TODO: Polygone anstatt Dreiecke; wirklich aus Originalmodell durchzählen???

            unsigned long numExpectedVertices = 3 * touchedFacets.size();
            unsigned long numExpectedEdgePts = numExpectedVertices * (_edgePointsPerEdge.getValue() - 1);

            /*unsigned long numOrigVertices = 0;
            unsigned long numOrigEdgePts = 0;
            for (Exact_Polyhedron_3::Facet_const_iterator fit = _modelToDraw.facets_begin(); fit != _modelToDraw.facets_end(); fit++)
            {
                if (std::find(touchedFacets.begin(), touchedFacets.end(), fit->index()) != touchedFacets.end())
                {
                    Exact_Polyhedron_3::Halfedge_around_facet_const_circulator hfit = fit->facet_begin();
                    do
                    {
                        numOrigVertices++;
                        numOrigEdgePts += _edgePointsPerEdge.getValue() - 1;
                        hfit++;
                    } while (hfit != fit->facet_begin());
                }
            }*/

            /// TODO: Das ist in den meisten Fällen falsch (da Clustering Vertices nicht mehrfach pro Seitenfläche zählt!)

            std::cout << "  vertices in original model: " << childCluster->numVertices() << " vs. cluster vertices count " << numExpectedVertices << std::endl;
            std::cout << "  edge points in original model: " << childCluster->numEdgePoints() << " vs. cluster edge points count " << numExpectedEdgePts << std::endl;

            if (childCluster->numVertices() != numExpectedVertices ||
                childCluster->numEdgePoints() != numExpectedEdgePts)
            {
                for (std::vector<unsigned long>::const_iterator fit = touchedFacets.begin(); fit != touchedFacets.end(); fit++)
                {
                    childCluster->clearEdgePointLists(false, *fit);
                    childCluster->clearVertexPointLists(false, *fit);
                }

                unsigned long numAddedVertices = 0;
                unsigned long numAddedEdgePts = 0;
                for (Exact_Polyhedron_3::Facet_const_iterator fit = _modelToDraw.facets_begin(); fit != _modelToDraw.facets_end(); fit++)
                {
                    if (std::find(touchedFacets.begin(), touchedFacets.end(), fit->index()) != touchedFacets.end())
                    {
                        Exact_Polyhedron_3::Halfedge_around_facet_const_circulator hfit = fit->facet_begin();
                        do
                        {
                            Exact_Polyhedron_3::Point_3 pt = hfit->vertex()->point();
                            Vector3 vtx(CGAL::to_double(pt.x()),
                                        CGAL::to_double(pt.y()),
                                        CGAL::to_double(pt.z()));

                            if (childCluster->addVertex(vtx, numAddedVertices, (unsigned long) fit->index()))
                                numAddedVertices++;

                            Exact_Polyhedron_3::Point_3 npt = hfit->next()->vertex()->point();
                            Vector3 nvtx(CGAL::to_double(npt.x()),
                                         CGAL::to_double(npt.y()),
                                         CGAL::to_double(npt.z()));

                            for (unsigned int p = 0; p < _edgePointsPerEdge.getValue(); p++)
                            {
                                Vector3 ep = vtx + ((nvtx - vtx) * (1.0f * p / _edgePointsPerEdge.getValue()));
                                if (childCluster->addEdgePoint(ep, numAddedEdgePts, hfit->index(), (unsigned long) fit->index()))
                                {
                                    if (hfit->opposite() != Exact_Polyhedron_3::Halfedge_handle() &&
                                        hfit->opposite()->facet() != Exact_Polyhedron_3::Facet_handle())
                                        childCluster->setEdgePointFacetIndex(numAddedEdgePts, hfit->opposite()->facet()->index());

                                    numAddedEdgePts++;
                                }
                            }

                            hfit++;
                        } while (hfit != fit->facet_begin());
                    }
                }
            }
        }
    }

    std::cout << "=== LGCPointModel::validateClusterStructure(" << getName() << ") END   ===" << std::endl;
}

void LGCPointModel::updateInternalGeometry()
{
    LGCCollisionModel::updateInternalGeometry();
    if (_transformChanged)
    {
        std::cout << "LGCPointModel::updateInternalGeometry('" << getName() << "')" << std::endl;
        std::cout << " prev. position = " << LGCTransformable<Real>::_prevPosition << ", current position = " << LGCTransformable<Real>::_position << std::endl;
        _pointCluster->transform(_position, _orientation);
        // std::cout << " transform centroids and normals" << std::endl;

        /*sofa::helper::WriteAccessor<Data<vector<Vector3> > > centroids(_faceCentroids);
        sofa::helper::WriteAccessor<Data<VecPointMaskOrigin > > gridOrigins(_pointGridOrigins);
        sofa::component::topology::MeshTopology::SeqTriangles triangles = _topology->getTriangles();

        Matrix3 oldInvRotation, newRotation;
        oldInvRotation.identity(); newRotation.identity();
        LGCTransformable<Real>::_prevOrientation.inverse().toMatrix(oldInvRotation);
        LGCTransformable<Real>::_orientation.toMatrix(newRotation);

        // std::cout << " prev. rotation (inv) = " << oldInvRotation << ", current rotation = " << newRotation << std::endl;

        for (unsigned long i = 0; i < triangles.size(); i++)
        {
            Vector3 transformedCentroid = oldInvRotation * centroids[i];
            transformedCentroid -= LGCTransformable<Real>::_prevPosition;
            transformedCentroid += LGCTransformable<Real>::_position;
            transformedCentroid = newRotation * transformedCentroid;

            centroids[i] = transformedCentroid;

            gridOrigins[i] = oldInvRotation * gridOrigins[i];
            gridOrigins[i] -= LGCTransformable<Real>::_prevPosition;
            gridOrigins[i] += LGCTransformable<Real>::_position;
            gridOrigins[i] = newRotation * gridOrigins[i];
        }*/
         _needsUpdate = true;
    }
}

//#define LGCPOINTMODEL_USE_OBSOLETE_BOUNDING_TREE
//#define LGCPOINTMODEL_USE_POINT_PRIMITIVES
void LGCPointModel::computeBoundingTree(int maxDepth)
{
    std::cout << "=== LGCPointModel::computeBoundingTree(" << this->getName() << "," << maxDepth << ") ===" << std::endl;
    std::cout << " center      : " << _pointCluster->clusterObb()->center() << std::endl;
    std::cout << " position    : " << this->position() << std::endl;
    std::cout << " orientation : " << this->orientation() << std::endl;
    std::cout << " half-extents: " << _pointCluster->clusterObb()->halfExtents() << std::endl;
    std::cout << " local X axis: " << _pointCluster->clusterObb()->localAxis(0) << std::endl;
    std::cout << " local Y axis: " << _pointCluster->clusterObb()->localAxis(1) << std::endl;
    std::cout << " local Z axis: " << _pointCluster->clusterObb()->localAxis(2) << std::endl;
    std::cout << " _localAxes  : " << _pointCluster->clusterObb()->wcData()._localAxes << std::endl;

    if (_computeOctree.getValue() != _pointCluster->computeOcTree())
    {
        _pointCluster->setComputeOcTree(_computeOctree.getValue());
    }

    if (_computeKdTree.getValue() != _pointCluster->computeKdTree())
    {
        _pointCluster->setComputeKdTree(_computeKdTree.getValue());
    }

    updateInternalGeometry();

    if (!_cubeModel)
        _cubeModel = createPrevious<CubeModel>();

    if (!_useCubeModel.getValue())
    {
        _cubeModel->resize(0);
        return;
    }

    if (!isMoving() && !_cubeModel->empty() && !_needsUpdate)
        return; // No need to recompute BBox if immobile

    if (_needsUpdate)
        _cubeModel->resize(0);

    _needsUpdate = false;

#ifndef LGCPOINTMODEL_USE_OBSOLETE_BOUNDING_TREE
    if (maxDepth == 0)
    {
        if (this->empty())
        {
            _cubeModel->resize(0);
        }
        else
        {
            _cubeModel->resize(1);
            Vector3 treeMin, treeMax;
            Vector3 he = _pointCluster->clusterObb()->halfExtents();

            Vector3 orientedObbCenter = this->position() + this->orientation().rotate(_pointCluster->clusterObb()->center());
            //Vector3 orientedModelPosition = this->position();
            Vector3 heTransform = orientedObbCenter;

            Vector3 tc0 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), he.y(), he.z()));
            Vector3 tc1 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), he.y(), -he.z()));
            Vector3 tc2 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), -he.y(), he.z()));
            Vector3 tc3 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), -he.y(), -he.z()));
            Vector3 tc4 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), he.y(), he.z()));
            Vector3 tc5 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), he.y(), -he.z()));
            Vector3 tc6 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), -he.y(), he.z()));
            Vector3 tc7 = heTransform + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), -he.y(), -he.z()));
            for (int c = 0; c < 3; c++)
            {
                treeMin[c] = tc0[c];
                treeMax[c] = tc0[c];

                if (tc1[c] > treeMax[c])
                    treeMax[c] = tc1[c];
                else if (tc1[c] < treeMin[c])
                    treeMin[c] = tc1[c];

                if (tc2[c] > treeMax[c])
                    treeMax[c] = tc2[c];
                else if (tc2[c] < treeMin[c])
                    treeMin[c] = tc2[c];

                if (tc3[c] > treeMax[c])
                    treeMax[c] = tc3[c];
                else if (tc3[c] < treeMin[c])
                    treeMin[c] = tc3[c];

                if (tc4[c] > treeMax[c])
                    treeMax[c] = tc4[c];
                else if (tc4[c] < treeMin[c])
                    treeMin[c] = tc4[c];

                if (tc5[c] > treeMax[c])
                    treeMax[c] = tc5[c];
                else if (tc5[c] < treeMin[c])
                    treeMin[c] = tc5[c];

                if (tc6[c] > treeMax[c])
                    treeMax[c] = tc6[c];
                else if (tc6[c] < treeMin[c])
                    treeMin[c] = tc6[c];

                if (tc7[c] > treeMax[c])
                    treeMax[c] = tc7[c];
                else if (tc7[c] < treeMin[c])
                    treeMin[c] = tc7[c];
            }

            _cubeModel->setLeafCube(0, std::make_pair(this->begin(),this->end()), treeMin, treeMax);
        }
    }
    else
    {
        _cubeModel->resize(this->getSize());
        Vector3 treeMin, treeMax;

        Vector3 orientedObbCenter = this->position() + this->orientation().rotate(_pointCluster->clusterObb()->center());

        Vector3 he = _pointCluster->clusterObb()->halfExtents();

        Vector3 tc0 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), he.y(), he.z()));
        Vector3 tc1 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), he.y(), -he.z()));
        Vector3 tc2 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), -he.y(), he.z()));
        Vector3 tc3 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(he.x(), -he.y(), -he.z()));
        Vector3 tc4 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), he.y(), he.z()));
        Vector3 tc5 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), he.y(), -he.z()));
        Vector3 tc6 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), -he.y(), he.z()));
        Vector3 tc7 = orientedObbCenter + this->orientation().rotate(_pointCluster->clusterObb()->wcData()._localAxes.transposed() * Vector3(-he.x(), -he.y(), -he.z()));

        for (int c = 0; c < 3; c++)
        {
            treeMin[c] = tc0[c];
            treeMax[c] = tc0[c];

            if (tc1[c] > treeMax[c])
                treeMax[c] = tc1[c];
            else if (tc1[c] < treeMin[c])
                treeMin[c] = tc1[c];

            if (tc2[c] > treeMax[c])
                treeMax[c] = tc2[c];
            else if (tc2[c] < treeMin[c])
                treeMin[c] = tc2[c];

            if (tc3[c] > treeMax[c])
                treeMax[c] = tc3[c];
            else if (tc3[c] < treeMin[c])
                treeMin[c] = tc3[c];

            if (tc4[c] > treeMax[c])
                treeMax[c] = tc4[c];
            else if (tc4[c] < treeMin[c])
                treeMin[c] = tc4[c];

            if (tc5[c] > treeMax[c])
                treeMax[c] = tc5[c];
            else if (tc5[c] < treeMin[c])
                treeMin[c] = tc5[c];

            if (tc6[c] > treeMax[c])
                treeMax[c] = tc6[c];
            else if (tc6[c] < treeMin[c])
                treeMin[c] = tc6[c];

            if (tc7[c] > treeMax[c])
                treeMax[c] = tc7[c];
            else if (tc7[c] < treeMin[c])
                treeMin[c] = tc7[c];
        }

        std::cout << " Tree level min/max: " << treeMin << " / " << treeMax << std::endl;
        _cubeModel->setParentOf(0, treeMin, treeMax);

        int maxBoxIdx = 0;
        for (unsigned int i = 0; i < _pointCluster->clusterObb()->numOBBChildren(); i++)
        {
            if (_pointCluster->clusterObb()->child(i)->depth() <= maxDepth)
            {
                maxBoxIdx += 1;
                computeBoundingTreeRec(_pointCluster->clusterObb()->child(i), maxBoxIdx, maxDepth);
                std::cout << "   "  << i << ": maxBoxIdx = " << maxBoxIdx << std::endl;
            }
        }
        _cubeModel->computeBoundingTree(maxDepth);
    }
    std::cout << "=== CubeModel new size: " << _cubeModel->getNumberCells() << " ===" << std::endl;
    for (unsigned int i = 0; i < _cubeModel->getNumberCells(); i++)
    {
        std::cout << "  * cell " << i << ": ";
        std::pair<core::CollisionElementIterator,core::CollisionElementIterator> ic = _cubeModel->getInternalChildren(i);
        if (ic.first.valid())
            std::cout << " child 1 = " << ic.first.getIndex() << ", ";

        if (ic.second.valid())
            std::cout << " child 2 = " << ic.second.getIndex();

        std::cout << std::endl;
    }
#else
#ifdef LGCPOINTMODEL_USE_POINT_PRIMITIVES
    if (_pointCluster->numSurfacePoints() || _pointCluster->numEdgePoints() > 0)
    {
        _cubeModel->resize(_pointCluster->numSurfacePoints() + _pointCluster->numEdgePoints());

        for (unsigned int i = 0; i < _pointCluster->numSurfacePoints(); i++)
        {
                const Vector3& pt = _pointCluster->surfacePoint(i);
                _cubeModel->setParentOf(i, pt, pt);
        }

        for (unsigned int i = 0; i < _pointCluster->numEdgePoints(); i++)
        {
                const Vector3& pt = _pointCluster->edgePoint(i);
                _cubeModel->setParentOf(i, pt, pt);
        }

        _cubeModel->computeBoundingTree(maxDepth);
    }
#else

    if (maxDepth == 0)
    {
        if (this->empty())
            _cubeModel->resize(0);
        else
        {
            _cubeModel->resize(1);
            Vector3 treeMin, treeMax;
            Vector3 tc0 = _pointCluster->clusterObb()->obrCorner(0);
            Vector3 tc1 = _pointCluster->clusterObb()->obrCorner(1);
            Vector3 tc2 = _pointCluster->clusterObb()->obrCorner(2);
            Vector3 tc3 = _pointCluster->clusterObb()->obrCorner(3);
            Vector3 tc4 = _pointCluster->clusterObb()->obrCorner(4);
            Vector3 tc5 = _pointCluster->clusterObb()->obrCorner(5);
            Vector3 tc6 = _pointCluster->clusterObb()->obrCorner(6);
            Vector3 tc7 = _pointCluster->clusterObb()->obrCorner(7);
            for (int c = 0; c < 3; c++)
            {
                treeMin[c] = tc0[c];
                treeMax[c] = tc0[c];

                if (tc1[c] > treeMax[c])
                    treeMax[c] = tc1[c];
                else if (tc1[c] < treeMin[c])
                    treeMin[c] = tc1[c];

                if (tc2[c] > treeMax[c])
                    treeMax[c] = tc2[c];
                else if (tc2[c] < treeMin[c])
                    treeMin[c] = tc2[c];

                if (tc3[c] > treeMax[c])
                    treeMax[c] = tc3[c];
                else if (tc3[c] < treeMin[c])
                    treeMin[c] = tc3[c];

                if (tc4[c] > treeMax[c])
                    treeMax[c] = tc4[c];
                else if (tc4[c] < treeMin[c])
                    treeMin[c] = tc4[c];

                if (tc5[c] > treeMax[c])
                    treeMax[c] = tc5[c];
                else if (tc5[c] < treeMin[c])
                    treeMin[c] = tc5[c];

                if (tc6[c] > treeMax[c])
                    treeMax[c] = tc6[c];
                else if (tc6[c] < treeMin[c])
                    treeMin[c] = tc6[c];

                if (tc7[c] > treeMax[c])
                    treeMax[c] = tc7[c];
                else if (tc7[c] < treeMin[c])
                    treeMin[c] = tc7[c];
            }

            _cubeModel->setLeafCube(0, std::make_pair(this->begin(),this->end()), treeMin, treeMax);
        }
    }
    else
    {
        _cubeModel->resize(_pointCluster->numChildren() + 1);

        Vector3 treeMin, treeMax;
        Vector3 tc0 = _pointCluster->clusterObb()->obrCorner(0);
        Vector3 tc1 = _pointCluster->clusterObb()->obrCorner(1);
        Vector3 tc2 = _pointCluster->clusterObb()->obrCorner(2);
        Vector3 tc3 = _pointCluster->clusterObb()->obrCorner(3);
        Vector3 tc4 = _pointCluster->clusterObb()->obrCorner(4);
        Vector3 tc5 = _pointCluster->clusterObb()->obrCorner(5);
        Vector3 tc6 = _pointCluster->clusterObb()->obrCorner(6);
        Vector3 tc7 = _pointCluster->clusterObb()->obrCorner(7);
        for (int c = 0; c < 3; c++)
        {
            treeMin[c] = tc0[c];
            treeMax[c] = tc0[c];

            if (tc1[c] > treeMax[c])
                treeMax[c] = tc1[c];
            else if (tc1[c] < treeMin[c])
                treeMin[c] = tc1[c];

            if (tc2[c] > treeMax[c])
                treeMax[c] = tc2[c];
            else if (tc2[c] < treeMin[c])
                treeMin[c] = tc2[c];

            if (tc3[c] > treeMax[c])
                treeMax[c] = tc3[c];
            else if (tc3[c] < treeMin[c])
                treeMin[c] = tc3[c];

            if (tc4[c] > treeMax[c])
                treeMax[c] = tc4[c];
            else if (tc4[c] < treeMin[c])
                treeMin[c] = tc4[c];

            if (tc5[c] > treeMax[c])
                treeMax[c] = tc5[c];
            else if (tc5[c] < treeMin[c])
                treeMin[c] = tc5[c];

            if (tc6[c] > treeMax[c])
                treeMax[c] = tc6[c];
            else if (tc6[c] < treeMin[c])
                treeMin[c] = tc6[c];

            if (tc7[c] > treeMax[c])
                treeMax[c] = tc7[c];
            else if (tc7[c] < treeMin[c])
                treeMin[c] = tc7[c];
        }

        _cubeModel->setParentOf(0, treeMin, treeMax);
        unsigned long aabbIdx = 1;
        for (unsigned long p = 0; p < _pointCluster->numChildren(); p++)
        {
            LGCPointCluster<Vec3Types>* child = _pointCluster->childCluster(p);
            LGCObb<Vec3Types>* clusterObb = child->clusterObb();
            if (clusterObb != NULL)
            {
                Vector3 cMin, cMax;
                Vector3 tc0 = clusterObb->obrCorner(0);
                Vector3 tc1 = clusterObb->obrCorner(1);
                Vector3 tc2 = clusterObb->obrCorner(2);
                Vector3 tc3 = clusterObb->obrCorner(3);
                Vector3 tc4 = clusterObb->obrCorner(4);
                Vector3 tc5 = clusterObb->obrCorner(5);
                Vector3 tc6 = clusterObb->obrCorner(6);
                Vector3 tc7 = clusterObb->obrCorner(7);
                for (int c = 0; c < 3; c++)
                {
                  cMin[c] = tc0[c];
                  cMax[c] = tc0[c];

                  if (tc1[c] > cMax[c])
                      cMax[c] = tc1[c];
                  else if (tc1[c] < cMin[c])
                      cMin[c] = tc1[c];

                  if (tc2[c] > cMax[c])
                      cMax[c] = tc2[c];
                  else if (tc2[c] < cMin[c])
                      cMin[c] = tc2[c];

                  if (tc3[c] > cMax[c])
                      cMax[c] = tc3[c];
                  else if (tc3[c] < cMin[c])
                      cMin[c] = tc3[c];

                  if (tc4[c] > cMax[c])
                      cMax[c] = tc4[c];
                  else if (tc4[c] < cMin[c])
                      cMin[c] = tc4[c];

                  if (tc5[c] > cMax[c])
                      cMax[c] = tc5[c];
                  else if (tc5[c] < cMin[c])
                      cMin[c] = tc5[c];

                  if (tc6[c] > cMax[c])
                      cMax[c] = tc6[c];
                  else if (tc6[c] < cMin[c])
                      cMin[c] = tc6[c];

                  if (tc7[c] > cMax[c])
                      cMax[c] = tc7[c];
                  else if (tc7[c] < cMin[c])
                      cMin[c] = tc7[c];
                }

                _cubeModel->setParentOf(aabbIdx, cMin, cMax);

                aabbIdx++;
            }
            else
            {
                serr << "Cluster " << child->getName() << " has no valid OBB pointer set!" << sendl;
            }
        }
        _cubeModel->computeBoundingTree(maxDepth);
    }
#endif
#endif
}

void LGCPointModel::computeBoundingTreeRec(LGCObb<Vec3Types>* obb, int &boxIndex, int maxDepth)
{
    std::cout << "  computeBoundingTreeRec(" << obb->identifier() << ")" << std::endl;
    Vector3 cMin, cMax;

    Vector3 childHe = obb->halfExtents();
    Vector3 rotatedChildOffset = this->orientation().rotate(obb->lcData()._childOffset);
    Vector3 tc0 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), childHe.y(), childHe.z()));
    Vector3 tc1 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), childHe.y(), -childHe.z()));
    Vector3 tc2 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), -childHe.y(), childHe.z()));
    Vector3 tc3 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), -childHe.y(), -childHe.z()));
    Vector3 tc4 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), childHe.y(), childHe.z()));
    Vector3 tc5 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), childHe.y(), -childHe.z()));
    Vector3 tc6 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), -childHe.y(), childHe.z()));
    Vector3 tc7 = this->position() + rotatedChildOffset + this->orientation().rotate(obb->wcData()._localAxes.transposed() *  Vector3(-childHe.x(), -childHe.y(), -childHe.z()));

    /*Vector3 tc0 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), childHe.y(), childHe.z()));
    Vector3 tc1 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), childHe.y(), -childHe.z()));
    Vector3 tc2 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), -childHe.y(), childHe.z()));
    Vector3 tc3 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(childHe.x(), -childHe.y(), -childHe.z()));
    Vector3 tc4 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), childHe.y(), childHe.z()));
    Vector3 tc5 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), childHe.y(), -childHe.z()));
    Vector3 tc6 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), -childHe.y(), childHe.z()));
    Vector3 tc7 = accumulatedChildOffsets + this->orientation().rotate(obb->wcData()._localAxes.transposed() * Vector3(-childHe.x(), -childHe.y(), -childHe.z()));*/

    for (int c = 0; c < 3; c++)
    {
        cMin[c] = tc0[c];
        cMax[c] = tc0[c];

        if (tc1[c] > cMax[c])
            cMax[c] = tc1[c];
        else if (tc1[c] < cMin[c])
            cMin[c] = tc1[c];

        if (tc2[c] > cMax[c])
            cMax[c] = tc2[c];
        else if (tc2[c] < cMin[c])
            cMin[c] = tc2[c];

        if (tc3[c] > cMax[c])
            cMax[c] = tc3[c];
        else if (tc3[c] < cMin[c])
            cMin[c] = tc3[c];

        if (tc4[c] > cMax[c])
            cMax[c] = tc4[c];
        else if (tc4[c] < cMin[c])
            cMin[c] = tc4[c];

        if (tc5[c] > cMax[c])
            cMax[c] = tc5[c];
        else if (tc5[c] < cMin[c])
            cMin[c] = tc5[c];

        if (tc6[c] > cMax[c])
            cMax[c] = tc6[c];
        else if (tc6[c] < cMin[c])
            cMin[c] = tc6[c];

        if (tc7[c] > cMax[c])
            cMax[c] = tc7[c];
        else if (tc7[c] < cMin[c])
            cMin[c] = tc7[c];
    }

    std::cout << "  " << boxIndex << ": min / max = " << cMin << " / " << cMax << std::endl;
    _cubeModel->setParentOf(boxIndex, cMin, cMax);
}

bool LGCPointModel::canCollideWith(CollisionModel *other)
{
    if (!this->f_printLog.getValue())
        this->f_printLog.setValue(true);

    sout << "LGCPointModel::canCollideWith(): " << this->getName() << " <-> " << other->getName() << " of class " << other->getClassName() << sendl;
    if (this == other)
    {
        sout << "No self-collision support, not OK." << sendl;
        return false;
    }

    if (dynamic_cast<LGCObbModel*>(other) != NULL)
    {
        sout << "Other model is-a LGCObbModel, OK." << sendl;
        return true;
    }

    if (dynamic_cast<LGCPointModel*>(other) != NULL)
    {
        sout << "Other model is-a LGCPointModel, OK." << sendl;
        return true;
    }

    /*if (dynamic_cast<CubeModel*>(other) != NULL)
    {
        sout << "Other model is-a CubeModel, OK." << sendl;
        return true;
    }*/
    return false;
}

bool LGCPointModel::canCollideWithElement(int index, CollisionModel* other, int otherIndex)
{
    std::cout << "LGCPointModel::canCollideWithElement(): " << this->getName() << " <-> " << other->getName() << " of class " << other->getClassName() << ", indices: " << index << " <-> " << otherIndex << std::endl;
    return false;
}

Surface_Point_Type LGCPointModel::surfacePointType(unsigned int x, unsigned int y, const Exact_Polyhedron_3::Facet_iterator &it)
{
    /*for (unsigned int i = 0; i < it->numSurfacePointsX(); i++)
    {
        for (unsigned int j = 0; j < it->numSurfacePointsY(); j++)
        {*/
            if (it->surfacePointType(x,y) == INSIDE_SURFACE)
            {
                bool edgeFound = false;
                if (y >= 1)
                {
                    if(it->surfacePointType(x,y - 1) == OUTSIDE_SURFACE)
                    {
                        std::cout << "   out -> in at " << x << "," << y - 1 << std::endl;
                        edgeFound = true;
                    }
                }
                else
                {
                    if(it->surfacePointType(x, 0) == OUTSIDE_SURFACE &&
                       it->surfacePointType(x, 1) == INSIDE_SURFACE)
                    {
                        std::cout << "   out -> in at " << x << "," << 0 << std::endl;
                        edgeFound = true;
                    }
                }

                if (y < it->numSurfacePointsY() - 1)
                {
                    if(it->surfacePointType(x,y + 1) == OUTSIDE_SURFACE)
                    {
                        std::cout << "   in -> out at " << x << "," << y + 1 << std::endl;
                        edgeFound = true;
                    }
                }
                else
                {
                    if(it->surfacePointType(x, y - 1) == INSIDE_SURFACE &&
                       it->surfacePointType(x, y) == OUTSIDE_SURFACE)
                    {
                        std::cout << "   out -> in at " << x << "," << y << std::endl;
                        edgeFound = true;
                    }
                }
                if (edgeFound)
                    return EDGE_OF_SURFACE;
                else
                    return INSIDE_SURFACE;
            }
            else
            {
                return OUTSIDE_SURFACE;
            }
        //}
    //}
    return UNKNOWN_SURFACE_TYPE;
}

Vec2i LGCPointModel::pointGridDimension(const unsigned int& facetIdx) const
{
    if (facetIdx < _model.size_of_facets())
    {
        ReadAccessor<Data<VecPointMaskDimension> > gridDimensions(_pointGridDimensions);
        return gridDimensions[facetIdx];
    }
    return Vec2i(0,0);
}

/// TODO: Grosses Problem mit surfacePoints bei rechtwinkligen, gleichschenkligen Dreiecken; vorübergehende Abhilfe: Zentroid als Platzhalter...
void LGCPointModel::createWitnessGrid()
{
    unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
    unsigned int tilesPerSide = std::sqrt(numTiles);
    std::cout << "LGCPointModel::createWitnessGrid() -- " << this->getName() << ": " << numTiles << " tiles, " << tilesPerSide << " per side" << std::endl;
    std::cout << " sizeof's: long = " << sizeof(long) << ", unsigned long = " << sizeof(unsigned long) << ", long long = " << sizeof(long long) << ", uint64_t = " << sizeof(uint64_t) << std::endl;

    sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);

    if (_model.size_of_facets() > 0 && meshTopology != NULL)
    {
        VecPointMask* surfacePoints = _pointGrids.beginEdit();
        surfacePoints->resize(_model.size_of_facets());

        VecPointMaskDiagonal* spSizeX = _pointGridSizeX.beginEdit();
        VecPointMaskDiagonal* spSizeY = _pointGridSizeY.beginEdit();
        VecPointMaskOrigin* spOrigins = _pointGridOrigins.beginEdit();
        VecPointMaskDimension* spDimensions = _pointGridDimensions.beginEdit();

        spOrigins->resize(_model.size_of_facets());
        spSizeX->resize(_model.size_of_facets());
        spSizeY->resize(_model.size_of_facets());
        spDimensions->resize(_model.size_of_facets());

        // vector<Vector3>* normals = _faceNormals.beginEdit();
        // vector<Vector3>* centroids = _faceCentroids.beginEdit();
        // VecPointMaskDiagonal* spDiagonals = _pointGridDiagonals.beginEdit();

        // normals->resize(_model.size_of_facets());
        // centroids->resize(_model.size_of_facets());
        // spDiagonals->resize(_model.size_of_facets());

        unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
        unsigned int tilesPerSide = std::sqrt(numTiles);

        Matrix3 modelRotation;
        LGCTransformable<Real>::_orientation.toMatrix(modelRotation);

        Matrix4 modelOrientation; modelOrientation.identity();
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                modelOrientation(i,j) = modelRotation(i,j);

        sofa::component::topology::MeshTopology::SeqTriangles triangles = meshTopology->getTriangles();
        ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));
        // ReadAccessor<Data<VecPointMaskOrigin> > gridOrigins(_pointGridOrigins);
        // ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeX(_pointGridSizeX);
        // ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeY(_pointGridSizeY);

        unsigned long facetIndex = 0;
        for (Exact_Polyhedron_3::Facet_iterator it = _model.facets_begin(); it != _model.facets_end(); it++)
        {
            /// WARNING: Does not work with "compressed" point masks; these have only "inside" info.
            /*Exact_Point_3 p0 = it->surfacePoint(0,0);
            Exact_Point_3 p1 = it->surfacePoint(0,1);
            Exact_Point_3 p2 = it->surfacePoint(1,0);*/

            Exact_Point_3 v0 = it->facet_begin()->vertex()->point();
            Exact_Vector_3 vp0(v0.x(), v0.y(), v0.z());

            std::cout << " * FACET " << facetIndex << ": pointGrid origin idx. = "
                      << it->pointGridOriginIndex() << ", "
                      << "pointGrid origin = " << it->obrCorner(it->pointGridOriginIndex()) << ", "
                      << "1st vertex: " << vp0
                      << ", point grid size = " << it->getPointGridSizeX() << " x " << it->getPointGridSizeY()
                      << ", point grid dimension = " << it->numSurfacePointsX() << " x " << it->numSurfacePointsY()
                      << std::endl;

            for (unsigned short k = 0; k <= 3; k++)
                std::cout << " - " << k << ": " << it->obrCorner(k) << std::endl;

            Exact_Vector_3 pointGridOrigin = it->obrCorner(it->pointGridOriginIndex());
            // Exact_Point_3 gridOriginPoint(p0.x(), p0.y(), p0.z());
            Exact_Vector_3 gridOriginOffset = pointGridOrigin - vp0;

            // Exact_Vector_3 sizeXOffset = p1 - p0;
            // Exact_Vector_3 sizeYOffset = p2 - p0;

            Vector3 originSP(CGAL::to_double(gridOriginOffset.x()), CGAL::to_double(gridOriginOffset.y()), CGAL::to_double(gridOriginOffset.z()));
            originSP = this->_orientation.inverseRotate(originSP);
            (*spOrigins)[facetIndex] = originSP;

            // Exact_Vector_3 diagonalOffset = (p3 - p0);
            // Vector3 originDiagonal(CGAL::to_double(diagonalOffset.x()), CGAL::to_double(diagonalOffset.y()), CGAL::to_double(diagonalOffset.z()));
            // std::cout << " grid diagonal " << facetIndex << ": " << originDiagonal << " = " << p3 << " - " << p0 << std::endl;
            // originDiagonal = this->_orientation.inverseRotate(originDiagonal);
            // (*spDiagonals)[facetIndex] = originDiagonal;

            Vector3 originSizeX = it->getPointGridSizeX(); //(CGAL::to_double(sizeXOffset.x()), CGAL::to_double(sizeXOffset.y()), CGAL::to_double(sizeXOffset.z()));
            Vector3 originSizeY = it->getPointGridSizeY(); //(CGAL::to_double(sizeYOffset.x()), CGAL::to_double(sizeYOffset.y()), CGAL::to_double(sizeYOffset.z()));
            originSizeX = this->_orientation.inverseRotate(originSizeX);
            originSizeY = this->_orientation.inverseRotate(originSizeY);
            (*spSizeX)[facetIndex] = originSizeX;
            (*spSizeY)[facetIndex] = originSizeY;

            // Exact_Vector_3 normalVec = it->normal();
            // Exact_Vector_3 centroidVec = it->centroid();
            // Exact_Point_3 centroidPoint(centroidVec.x(), centroidVec.y(), centroidVec.z());
            // Exact_Vector_3 centroidOffset = centroidPoint - v0;

            // std::cout << " centroidOffset " << centroidOffset << " = " << v0 << " - " << centroidPoint << std::endl;

            /*Vector3 originNormal(CGAL::to_double(normalVec.x()), CGAL::to_double(normalVec.y()), CGAL::to_double(normalVec.z()));
            originNormal = this->_orientation.inverseRotate(originNormal);
            (*normals)[facetIndex] = originNormal;

            Vector3 originCentroid(CGAL::to_double(centroidOffset.x()), CGAL::to_double(centroidOffset.y()), CGAL::to_double(centroidOffset.z()));
            originCentroid = this->_orientation.inverseRotate(originCentroid);
            (*centroids)[facetIndex] = originCentroid;*/

            /// Build surface point mask locally.
            Vector3 corner0 = meshPoints[triangles[facetIndex][0]];
            Vector3 corner1 = meshPoints[triangles[facetIndex][1]];
            Vector3 corner2 = meshPoints[triangles[facetIndex][2]];

            std::cout << "   facet " << facetIndex << " indices : " << triangles[facetIndex][0] << "," << triangles[facetIndex][1] << "," << triangles[facetIndex][2] << std::endl;
            std::cout << "   facet " << facetIndex << " vertices: " << corner0 << "/" << corner1 << "/" << corner2 << std::endl;

            corner0 = modelOrientation.transform(corner0);
            corner0 += position();
            corner1 = modelOrientation.transform(corner1);
            corner1 += position();
            corner2 = modelOrientation.transform(corner2);
            corner2 += position();

            Vector3 corner0Offset = corner0 - this->_position;
            Vector3 gridOriOffset = originSP;
            Vector3 gridStepX = originSizeX;
            Vector3 gridStepY = originSizeY;

            Vector3 gridPt1 = this->_position;
            Vector3 gridPt15 = gridPt1 + corner0Offset;
            Vector3 gridPt2 = gridPt15 + modelOrientation.transform(gridOriOffset);

            Vec<4, unsigned long> pointMask;
            for (unsigned short l = 0; l < 4; l++)
                pointMask[l] = 0;

            unsigned long numSurfacePts = 0;

            Vec<2, int> pointMaskDimension(it->numSurfacePointsX(), it->numSurfacePointsY());
            (*spDimensions)[facetIndex] = pointMaskDimension;

            for (unsigned int p = 0; p <= it->numSurfacePointsX(); p++)
            {
                for (unsigned int q = 0; q <= it->numSurfacePointsY(); q++)
                {
                    Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                    bool pointIsIn = pointResidesInTriangle(gp, corner0, corner1, corner2);
                    std::cout << "   " << p << "," << q << " inside: " << pointIsIn << std::endl;
                    if (pointIsIn)
                    {
                        /*Exact_Point_3 pt(gp.x(), gp.y(), gp.z());
                        it->addSurfacePoint(p, q, pt, INSIDE_SURFACE);*/

                        numSurfacePts++;

                        unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                        unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxX = 0;
                        if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxX = p;
                        else
                            tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxY = 0;
                        if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxY = q;
                        else
                            tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                        unsigned long shift = (unsigned long) (pow(2, targetedBit));

                        std::cout << "     inside pt: " << p << "," << q << ": tileX = " << tileX << ", tileY = " << tileY << std::endl;
                        /*std::cout << "       sum check: (" << tileX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxX << "," <<
                                                              tileY * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << ")" << std::endl;

                        std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), target bit = " << targetedBit << std::endl;
                        std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << shift << std::endl;
                        std::cout << "       tile " << tilesPerSide * tileX + tileY << " before: " << pointMask[tilesPerSide * tileX + tileY] << std::endl;*/
                        pointMask[tilesPerSide * tileX + tileY] |= shift;
                        std::cout << "       tile " << tilesPerSide * tileX + tileY << " after: " << pointMask[tilesPerSide * tileX + tileY] << std::endl;
                    }
                }
            }

            if (numSurfacePts == 0)
            {
                std::cout << "WARNING: Second pass for facet; vertex order reversed" << std::endl;
                for (unsigned short l = 0; l < 4; l++)
                    pointMask[l] = 0;

                for (unsigned int p = 0; p <= it->numSurfacePointsX(); p++)
                {
                    for (unsigned int q = 0; q <= it->numSurfacePointsY(); q++)
                    {
                        Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                        bool pointIsIn = pointResidesInTriangle(gp, corner0, corner1, corner2);
                        // std::cout << "   " << p << "," << q << " inside: " << pointIsIn << std::endl;
                        if (pointIsIn)
                        {
                            /*Exact_Point_3 pt(gp.x(), gp.y(), gp.z());
                            it->addSurfacePoint(p, q, pt, INSIDE_SURFACE);*/

                            numSurfacePts++;

                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = q;
                            else
                                tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                            unsigned long shift = (unsigned long) (pow(2, targetedBit));

                            /*std::cout << "     inside pt: " << p << "," << q << ": tileX = " << tileX << ", tileY = " << tileY << std::endl;
                            std::cout << "       sum check: (" << tileX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxX << "," <<
                                                                  tileY * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << ")" << std::endl;

                            std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), target bit = " << targetedBit << std::endl;
                            std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << shift << std::endl;
                            std::cout << "       tile " << tilesPerSide * tileX + tileY << " before: " << pointMask[tilesPerSide * tileX + tileY] << std::endl;*/
                            pointMask[tilesPerSide * tileX + tileY] |= shift;
                            // std::cout << "       tile " << tilesPerSide * tileX + tileY << " after: " << pointMask[tilesPerSide * tileX + tileY] << std::endl;
                        }
                    }
                }

                /*for (unsigned int p = 0; p < it->numSurfacePointsX(); p++)
                {
                    for (unsigned int q = 0; q < it->numSurfacePointsY(); q++)
                    {
                        if (it->surfacePointType(p,q) == INSIDE_SURFACE)
                        {
                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = q;
                            else
                                tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                            unsigned long shift = (unsigned long) (pow(2, targetedBit));
                            pointMask[tilesPerSide * tileX + tileY] |= shift;
                        }
                    }
                }*/
            }

            (*surfacePoints)[facetIndex] = pointMask;

            for (unsigned short m = 0; m <= 3; m++)
            {
                long tileMask = pointMask[m];
                std::cout << " facet " << facetIndex << ", tile " << m << ", set bits: ";
                for (unsigned short r = 0; r < LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE; r++)
                {
                    if (tileMask & (1ul << r))
                    {
                        std::cout << " " << r;
                        std::cout << " (" << r / LGC_POINT_MODEL_GRID_TILE_SIZE << "," << r % LGC_POINT_MODEL_GRID_TILE_SIZE << ")";
                    }
                }
                std::cout << std::endl;
            }

            facetIndex++;
        }
#if 0


                for (unsigned int p = 0; p <= it->numSurfacePointsX(); p++)
                {
                    for (unsigned int q = 0; q <= it->numSurfacePointsY(); q++)
                    {
                        Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                        if (it->surfacePointType(p,q) == INSIDE_SURFACE)
                        {
                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = q;
                            else
                                tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long idx = ((unsigned long)1 << (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY));
                            std::cout << "     inside pt: " << p << "," << q << " at index pos. " << LGC_POINT_MODEL_GRID_SIZE * (p) + (q)  << "; tileX = " << tileX << ", tileY = " << tileY << std::endl;
                            std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), bit " << tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << std::endl;
                            std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << idx << std::endl;
                            pointMask[tilesPerSide * tileX + tileY] |= idx;
                        }
                    }
                }
                (*surfacePoints)[facetIndex] = pointMask;
            }
            facetIndex++;
        }

                for (unsigned int p = 0; p <= it->numSurfacePointsX(); p++)
                {
                    unsigned int startIdx = 0, endIdx = 0;
                    bool startFound = false;
                    bool endFound = false;
                    /*
                    Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                    if (pointResidesInTriangle(gp, corner0, corner1, corner2))
                    {
                        unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                        unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxX = 0;
                        if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxX = p;
                        else
                            tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxY = 0;
                        if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxY = q;
                        else
                            tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned long idx = ((unsigned long)1 << (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY));
                        std::cout << "     inside pt: " << p << "," << q << " at index pos. " << LGC_POINT_MODEL_GRID_SIZE * (p) + (q)  << "; tileX = " << tileX << ", tileY = " << tileY << std::endl;
                        std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), bit " << tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << std::endl;
                        std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << idx << std::endl;
                        pointMask[tilesPerSide * tileX + tileY] |= idx;
                    }
                     */

                    for (unsigned int q = 0; q <= it->numSurfacePointsY(); q++)
                    {
                        Vector3 gp(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * q));
                        Vector3 gp_m1(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * (q-1)));
                        Vector3 gp_p1(gridPt2 + modelOrientation.transform(gridStepX * p) - modelOrientation.transform(gridStepY * (q+1)));
                        if (!startFound)
                        {
                            if (pointResidesInTriangle(gp, corner0, corner1, corner2))
                            {
                                if (q > 0)
                                {
                                    if (!pointResidesInTriangle(gp_m1, corner0, corner1, corner2))
                                    {
                                        std::cout << "   startFound at " << p << "," << q-1 << " as EDGE_OF/OUTSIDE_SURFACE" << std::endl;
                                        startFound = true;
                                        startIdx = q-1;
                                        if (!pointResidesInTriangle(gp_p1, corner0, corner1, corner2))
                                        {
                                            endFound = true;
                                            endIdx = q+1;
                                            std::cout << "   endFound at " << p << "," << q+1 << " as EDGE_OF/OUTSIDE_SURFACE: Corner edge case!" << std::endl;
                                        }
                                    }
                                }
                                else
                                {
                                    startFound = true;
                                    std::cout << "   startFound at " << p << "," << 0 << " as beginning of line" << std::endl;
                                    startIdx = 0;
                                    if (!pointResidesInTriangle(gp_p1, corner0, corner1, corner2))
                                    {
                                        std::cout << "   endFound at " << p << "," << q+1 << " as EDGE_OF/OUTSIDE_SURFACE" << std::endl;
                                        endIdx = q+1;
                                        endFound = true;
                                    }
                                }
                                std::cout << "'line' " << p << ": startFound at " << startIdx << std::endl;
                            }
                            else //if (!pointResidesInTriangle(gp, corner0, corner1, corner2))
                            {
                                if (q >= 1)
                                {
                                    if (!(pointResidesInTriangle(gp_m1, corner0, corner1, corner2)) &&
                                        !(pointResidesInTriangle(gp_p1, corner0, corner1, corner2)))
                                    {
                                         startFound = true;
                                         endFound = true;
                                         startIdx = q-1;
                                         endIdx = q+1;
                                         std::cout << "   in-line corner detected at: " << p << "," << q << std::endl;
                                    }
                                }
                            }
                        }
                        else if (startFound)
                        {
                            if (!pointResidesInTriangle(gp, corner0, corner1, corner2))
                            {
                                std::cout << "   endFound at " << p << "," << q << " as OUTSIDE_SURFACE" << std::endl;
                                endIdx = q;
                                endFound = true;
                            }
                            else
                            {
                                if (q < it->numSurfacePointsY() - 1)
                                {
                                    if (!pointResidesInTriangle(gp_p1, corner0, corner1, corner2))
                                    {
                                        std::cout << "   endFound at " << p << "," << q+1 << " as OUTSIDE_SURFACE" << std::endl;
                                        endIdx = q+1;
                                        endFound = true;
                                    }
                                }
                            }

                            if (endIdx > 0)
                            {
                                std::cout << "'line' " << p << ": endFound at " << endIdx << std::endl;
                                endFound = true;
                            }
                        }

                        if (startFound && endFound)
                            break;
                    }

                    std::cout << "   line " << p << ": startFound = " << startFound << ", endFound = " << endFound << ", startIdx = " << startIdx << ", endIdx = " << endIdx << std::endl;

                    if (startIdx == 0 && endIdx == 0)
                        std::cout << "   'line' " << p << ": Outside" << std::endl;
                    else if (startIdx >= 0 && endIdx > 0 && (endIdx - startIdx) <= 2)
                        std::cout << "   'line' " << p << ": Edge case" << std::endl;
                    else
                    {
                        std::cout << "   'line' " << p << ": Inside; start at " << startIdx << ", end at " << endIdx << ", startFound = " << startFound << std::endl;
                        for (unsigned int s = startIdx; s <= endIdx; s++)
                        {
                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (s) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (s < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = s;
                            else
                                tileIdxY = s % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long idx = ((unsigned long)1 << (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY));
                            std::cout << "     inside pt: " << p << "," << s << " at index pos. " << LGC_POINT_MODEL_GRID_SIZE * (p) + (s)  << "; tileX = " << tileX << ", tileY = " << tileY << std::endl;
                            std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), bit " << tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << std::endl;
                            std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << idx << std::endl;
                            pointMask[tilesPerSide * tileX + tileY] |= idx;
                        }
                    }
                }

                (*surfacePoints)[facetIndex] = pointMask;
            }

            /// This part is severely broken! Build surface point masks from here, instead from original CGAL polyhedron.
            for (unsigned int i = 0; i < it->numSurfacePointsX(); i++)
            {
                std::cout << i << ": ";
                for (unsigned int j = 0; j < it->numSurfacePointsY(); j++)
                {
                    if (it->surfacePointType(i,j) == INSIDE_SURFACE)
                        std::cout << "1 ";
                    else
                        std::cout << "0 ";
                }
                std::cout << std::endl;
            }

            std::cout << "  * facet " << facetIndex << ": grid size " << it->numSurfacePointsX() << "x" << it->numSurfacePointsY() << std::endl;

            for (unsigned int p = 0; p < it->numSurfacePointsX(); p++)
            {
                unsigned int startIdx = 0, endIdx = 0;
                bool startFound = false;
                bool endFound = false;
                for (unsigned int q = 0; q < it->numSurfacePointsY(); q++)
                {
                    if (!startFound)
                    {
                        if (surfacePointType(p, q, it) == INSIDE_SURFACE)
                        {
                            if (q > 0)
                            {
                                if (surfacePointType(p, q-1, it) == EDGE_OF_SURFACE ||
                                    surfacePointType(p, q-1, it) == OUTSIDE_SURFACE)
                                {
                                    std::cout << "   startFound at " << p << "," << q-1 << " as EDGE_OF/OUTSIDE_SURFACE" << std::endl;
                                    startFound = true;
                                    startIdx = q-1;
                                    if (surfacePointType(p, q+1, it) == EDGE_OF_SURFACE ||
                                        surfacePointType(p, q+1, it) == OUTSIDE_SURFACE)
                                    {
                                        endFound = true;
                                        endIdx = q+1;
                                        std::cout << "   endFound at " << p << "," << q+1 << " as EDGE_OF/OUTSIDE_SURFACE: Corner edge case!" << std::endl;
                                    }
                                }
                            }
                            else
                            {
                                startFound = true;
                                std::cout << "   startFound at " << p << "," << 0 << " as beginning of line" << std::endl;
                                startIdx = 0;
                                if (surfacePointType(p, q+1, it) == EDGE_OF_SURFACE ||
                                    surfacePointType(p, q+1, it) == OUTSIDE_SURFACE)
                                {
                                    std::cout << "   endFound at " << p << "," << q+1 << " as EDGE_OF/OUTSIDE_SURFACE" << std::endl;
                                    endIdx = q+1;
                                    endFound = true;
                                }
                            }
                            std::cout << "'line' " << p << ": startFound at " << startIdx << std::endl;
                        }
                        else if (surfacePointType(p, q, it) == EDGE_OF_SURFACE)
                        {
                            if (q >= 1)
                            {
                                if ((surfacePointType(p, q+1, it) == EDGE_OF_SURFACE ||
                                    surfacePointType(p, q+1, it) == OUTSIDE_SURFACE) &&
                                    (surfacePointType(p, q-1, it) == EDGE_OF_SURFACE ||
                                     surfacePointType(p, q-1, it) == OUTSIDE_SURFACE))
                                {
                                     startFound = true;
                                     endFound = true;
                                     startIdx = q-1;
                                     endIdx = q+1;
                                     std::cout << "   in-line corner detected at: " << p << "," << q << std::endl;
                                }
                            }
                        }
                    }
                    else if (startFound)
                    {
                        if (surfacePointType(p, q, it) == OUTSIDE_SURFACE ||
                            surfacePointType(p, q, it) == EDGE_OF_SURFACE)
                        {
                            std::cout << "   endFound at " << p << "," << q << " as OUTSIDE_SURFACE" << std::endl;
                            endIdx = q;
                            endFound = true;
                        }
                        /*else if (surfacePointType(p, q, it) == EDGE_OF_SURFACE)
                        {
                            std::cout << "   endFound at " << p << "," << q << " as EDGE_OF_SURFACE" << std::endl;
                            endIdx = q;
                            endFound = true;
                        }*/
                        else
                        {
                            if (q < it->numSurfacePointsY() - 1)
                            {
                                if (surfacePointType(p, q + 1, it) == EDGE_OF_SURFACE ||
                                    surfacePointType(p, q + 1, it) == OUTSIDE_SURFACE)
                                {
                                    std::cout << "   endFound at " << p << "," << q+1 << " as EDGE_OF_SURFACE" << std::endl;
                                    endIdx = q+1;
                                    endFound = true;
                                }

                                /*if (surfacePointType(p, q + 1, it) == OUTSIDE_SURFACE)
                                {
                                    std::cout << "   endFound at " << p << "," << q << " as OUTSIDE_SURFACE" << std::endl;
                                    endIdx = q;
                                    endFound = true;
                                }*/
                            }
                        }

                        if (endIdx > 0)
                        {
                            std::cout << "'line' " << p << ": endFound at " << endIdx << std::endl;
                            endFound = true;
                        }
                    }

                    if (startFound && endFound)
                        break;
                }

                std::cout << "   line " << p << ": startFound = " << startFound << ", endFound = " << endFound << ", startIdx = " << startIdx << ", endIdx = " << endIdx << std::endl;

                if (startIdx == 0 && endIdx == 0)
                    std::cout << "   'line' " << p << ": Outside" << std::endl;
                else if (startIdx >= 0 && endIdx > 0 && (endIdx - startIdx) <= 2)
                    std::cout << "   'line' " << p << ": Edge case" << std::endl;
                else
                {
                    std::cout << "   'line' " << p << ": Inside; start at " << startIdx << ", end at " << endIdx << ", startFound = " << startFound << std::endl;
                    for (unsigned int s = startIdx; s <= endIdx; s++)
                    {
                        unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                        unsigned int tileY = (s) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxX = 0;
                        if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxX = p;
                        else
                            tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned int tileIdxY = 0;
                        if (s < LGC_POINT_MODEL_GRID_TILE_SIZE)
                            tileIdxY = s;
                        else
                            tileIdxY = s % LGC_POINT_MODEL_GRID_TILE_SIZE;

                        unsigned long idx = ((unsigned long)1 << (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY));
                        std::cout << "     inside pt: " << p << "," << s << " at index pos. " << LGC_POINT_MODEL_GRID_SIZE * (p) + (s)  << "; tileX = " << tileX << ", tileY = " << tileY << std::endl;
                        std::cout << "       tile (" << tileX << "," << tileY << "), in tile: (" << tileIdxX << "," << tileIdxY << "), bit " << tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY << std::endl;
                        std::cout << "       or'ing tile " << tilesPerSide * tileX + tileY << " with " << idx << std::endl;
                        pointMask[tilesPerSide * tileX + tileY] |= idx;
                    }
                }
            }
            (*surfacePoints)[facetIndex] = pointMask;

            for (unsigned short m = 0; m <= 3; m++)
            {
                long tileMask = pointMask[m];
                std::cout << " facet " << facetIndex << ", tile " << m << ", set bits: ";
                for (unsigned short r = 0; r < LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE; r++)
                {
                    if (tileMask & (1ul << r))
                    {
                        std::cout << " " << r;
                        std::cout << " (" << r / LGC_POINT_MODEL_GRID_TILE_SIZE << "," << r % LGC_POINT_MODEL_GRID_TILE_SIZE << ")";
                    }
                }
                std::cout << std::endl;
            }
            facetIndex++;

        }
#endif
        // _faceNormals.endEdit();
        // _faceCentroids.endEdit();
        // _pointGridDiagonals.endEdit();
        _pointGrids.endEdit();
        _pointGridOrigins.endEdit();
        _pointGridSizeX.endEdit();
        _pointGridSizeY.endEdit();
        _pointGridDimensions.endEdit();

#if 0
        ReadAccessor<Data<VecPointMask> > surfPoints(_pointGrids);
        ReadAccessor<Data<VecPointMaskDiagonal> > sizesX(_pointGridSizeX);
        ReadAccessor<Data<VecPointMaskDiagonal> > sizesY(_pointGridSizeY);
        std::cout << "=== surfacePoints for facets: " << surfPoints.size() << " ===" << std::endl;
        if (surfPoints.size() > 0)
        {
            unsigned int numTiles = (LGC_POINT_MODEL_GRID_SIZE * LGC_POINT_MODEL_GRID_SIZE) / (LGC_POINT_MODEL_GRID_TILE_SIZE * LGC_POINT_MODEL_GRID_TILE_SIZE);
            unsigned int tilesPerSide = std::sqrt(numTiles);

            for (unsigned long k = 0; k < surfPoints.size(); k++)
            {
                std::cout << " * Facet " << k << ": gridStepX = " << sizesX[k] << ", gridStepY = " << sizesY[k] << std::endl;
                {
                    for (unsigned int p = 0; p < tilesPerSide * LGC_POINT_MODEL_GRID_TILE_SIZE; p++)
                    {
                        std::cout << p << ": ";
                        for (unsigned int q = 0; q < tilesPerSide * LGC_POINT_MODEL_GRID_TILE_SIZE; q++)
                        {
                            unsigned int tileX = (p) / LGC_POINT_MODEL_GRID_TILE_SIZE;
                            unsigned int tileY = (q) / LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxX = 0;
                            if (p < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxX = p;
                            else
                                tileIdxX = p % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned int tileIdxY = 0;
                            if (q < LGC_POINT_MODEL_GRID_TILE_SIZE)
                                tileIdxY = q;
                            else
                                tileIdxY = q % LGC_POINT_MODEL_GRID_TILE_SIZE;

                            unsigned long targetedBit = (tileIdxX * LGC_POINT_MODEL_GRID_TILE_SIZE + tileIdxY);
                            unsigned long shift = (unsigned long) (pow(2, targetedBit));

                            if (surfPoints[k][tilesPerSide * tileX + tileY] & shift)
                            {
                                std::cout << "1 ";
                            }
                            else
                            {
                                std::cout << "0 ";
                            }
                        }
                        std::cout << std::endl;
                    }
                }
            }
        }
#endif
    }
}

void LGCPointModel::buildConvexDecomposition()
{
    std::cout << "LGCPointModel::buildConvexDecomposition(" << this->getName() << ")" << std::endl;

    std::vector< HACD::Vec3<HACD::Real> > points;
    std::vector< HACD::Vec3<long> > triangles;

    sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);
    sofa::component::topology::MeshTopology::SeqTriangles meshTriangles = meshTopology->getTriangles();
    ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));

    std::cout << " adding points from topology: " << meshPoints.size() << std::endl;
    for(int i = 0; i < meshPoints.size(); i++)
    {
        std::cout << " - " << meshPoints[i] << std::endl;
        HACD::Vec3<HACD::Real> vertex(meshPoints[i][0], meshPoints[i][1], meshPoints[i][2]);
        points.push_back(vertex);
    }

    std::cout << " adding triangles from topology: " << meshTriangles.size() << std::endl;
    for(int i = 0; i < meshTriangles.size(); i++)
    {
        std::cout << " - " << meshTriangles[i][0] << "," << meshTriangles[i][1] << "," << meshTriangles[i][2] << std::endl;
        HACD::Vec3<long> triangle(meshTriangles[i][0], meshTriangles[i][1], meshTriangles[i][2]);
        triangles.push_back(triangle);
    }

    _hacdHeapManager = HACD::createHeapManager(65536*(1000));
    _hacd = HACD::CreateHACD(_hacdHeapManager);

    _hacd->SetPoints(&points[0]);
    _hacd->SetNPoints(points.size());
    _hacd->SetTriangles(&triangles[0]);
    _hacd->SetNTriangles(triangles.size());

    // HACD parameters
    size_t nClusters = 2 /*atoi(2)*/;
    double concavity = 100 /*atof(100)*/;
    bool addExtraDistPoints = true /*(atoi(argv[5]) == 0)?false:true*/;
    bool addFacesPoints = true /*(atoi(argv[6]) == 0)?false:true*/;
    double ccConnectDist = 30 /*atof(argv[7])*/;
    size_t targetNTrianglesDecimatedMesh = 2000 /*atoi(argv[8])*/;

    _hacd->SetCompacityWeight(0.0001);
    _hacd->SetVolumeWeight(0.0);
    _hacd->SetConnectDist(ccConnectDist);               // if two connected components are seperated by distance < ccConnectDist
                                                        // then create a virtual edge between them so the can be merged during
                                                        // the simplification process

    _hacd->SetNClusters(nClusters);                     // minimum number of clusters
    _hacd->SetNVerticesPerCH(100);                      // max of 100 vertices per convex-hull
    _hacd->SetConcavity(concavity);                     // maximum concavity
    _hacd->SetSmallClusterThreshold(0.25);				 // threshold to detect small clusters
    _hacd->SetNTargetTrianglesDecimatedMesh(targetNTrianglesDecimatedMesh); // # triangles in the decimated mesh
    _hacd->SetAddExtraDistPoints(addExtraDistPoints);
    _hacd->SetAddFacesPoints(addFacesPoints);

    _hacd->Compute();
    nClusters = _hacd->GetNClusters();

    std::cout << "Clusters of decomposition: " << nClusters << std::endl;
    for (int c=0;c<nClusters;c++)
    {
        //generate convex result
        size_t nPoints = _hacd->GetNPointsCH(c);
        size_t nTriangles = _hacd->GetNTrianglesCH(c);

        //std::cout << " * cluster " << c << ": " << nPoints << " points, " << nTriangles << " triangles." << std::endl;

        HACD::Vec3<HACD::Real> * chPoints = new HACD::Vec3<HACD::Real>[nPoints];
        HACD::Vec3<long> * chTriangles = new HACD::Vec3<long>[nTriangles];
        _hacd->GetCH(c, chPoints, chTriangles);

        std::cout << " * cluster " << c << ": " << nPoints << " points." << std::endl;
        for(size_t v = 0; v < nPoints; ++v)
        {
            std::cout << "    " << v << ": "
                      << chPoints[v].X() << ","
                      << chPoints[v].Y() << ","
                      << chPoints[v].Z() << std::endl;
        }
        std::cout << " * cluster " << c << ": " << nTriangles << " triangles." << std::endl;
        for(size_t f = 0; f < nTriangles; ++f)
        {
            std::cout << "    " << f << ": "
                        << chTriangles[f].X() << ","
                        << chTriangles[f].Y() << ","
                        << chTriangles[f].Z() << std::endl;
        }

        /*std::vector<pcl::LGCPointTypeMin> clusterVertices;
        for (size_t i = 0; i < nPoints; i++)
        {
            pcl::LGCPointTypeMin pt;
            pt.x = chPoints[i].X();
            pt.y = chPoints[i].Y();
            pt.z = chPoints[i].Z();

            clusterVertices.push_back(pt);
        }*/

        delete[] chPoints;
        delete[] chTriangles;

        /// WICHTIG: Für Kind-Cluster leere Vertex-/Edge-/Surface-Punkt-Liste übergeben! Diese werden in createChildCluster() erstellt.
        LGCPointCluster<Vec3Types>* childCluster = new LGCPointCluster<Vec3Types>(std::vector<pcl::LGCPointTypeMin>(), std::vector<pcl::LGCPointTypeMin>(), std::vector<pcl::LGCPointTypeMin>(),
                                                                                 _pointCluster->position(), _pointCluster->orientation(), PARENT_RELATIVE_REFERENCE_FRAME, _pointCluster, _pointCluster->collisionModel());

        std::stringstream nameStream;
        nameStream << getName() << "_child_" << c;
        childCluster->setName(nameStream.str());

        childCluster->setClusterColor(sofa::helper::randomVec4<Vec3Types::Real>());

        createClusterGrid(c, childCluster);

        if (childCluster->writePCDFile(childCluster->getName()))
        {
            childCluster->setDoSegmentation(_doSegmentation.getValue());
            childCluster->readFromPCD();

            childCluster->setOriginalModelPtr(&_model);

            if (_computeOctree.getValue())
            {
                childCluster->setComputeOcTree(true);
            }

            if (_computeKdTree.getValue())
            {
                childCluster->setComputeKdTree(true);
            }

            _pointCluster->addChild(childCluster);
            _clusterOctrees.insert(std::make_pair(c, childCluster->clusterOctreeGPU()));
        }
    }
}

void LGCPointModel::createClusterGrid(size_t clusterIdx, LGCPointCluster<Vec3Types>* childCluster)
{
    std::cout << "LGCPointModel::createClusterGrid(" << this->getName() << "), child " << clusterIdx << std::endl;
    if (_hacd && _hacdHeapManager)
    {
        if (clusterIdx < _hacd->GetNClusters())
        {
            sofa::component::topology::MeshTopology* meshTopology = dynamic_cast<sofa::component::topology::MeshTopology*>(LGCCollisionModelBase::_topology);
            sofa::component::topology::MeshTopology::SeqTriangles meshTriangles = meshTopology->getTriangles();
            ReadAccessor<Data<VecCoord> > meshPoints(_mState->read(core::ConstVecCoordId::position()));

            size_t nPoints = _hacd->GetNPointsCH(clusterIdx);
            size_t nTriangles = _hacd->GetNTrianglesCH(clusterIdx);

            HACD::Vec3<HACD::Real> * chPoints = new HACD::Vec3<HACD::Real>[nPoints];
            HACD::Vec3<long> * chTriangles = new HACD::Vec3<long>[nTriangles];
            _hacd->GetCH(clusterIdx, chPoints, chTriangles);

            for (size_t t = 0; t < nTriangles; t++)
            {
                std::cout << " - " << t << ": "
                            << chTriangles[t].X() << ", "
                            << chTriangles[t].Y() << ", "
                            << chTriangles[t].Z() << "; points: ";

                std::cout << chPoints[chTriangles[t].X()].X() << "," << chPoints[chTriangles[t].X()].Y() << "," << chPoints[chTriangles[t].X()].Z() << " / ";
                std::cout << chPoints[chTriangles[t].Y()].X() << "," << chPoints[chTriangles[t].Y()].Y() << "," << chPoints[chTriangles[t].Y()].Z() << " / ";
                std::cout << chPoints[chTriangles[t].Z()].X() << "," << chPoints[chTriangles[t].Z()].Y() << "," << chPoints[chTriangles[t].Z()].Z() << std::endl;

                HACD::Vec3<HACD::Real> h0 = chPoints[chTriangles[t].X()];
                HACD::Vec3<HACD::Real> h1 = chPoints[chTriangles[t].Y()];
                HACD::Vec3<HACD::Real> h2 = chPoints[chTriangles[t].Z()];

                childCluster->_cvPlanes.push_back(Plane3D<Vec3Types::Real>(Vector3(h0.X(), h0.Y(), h0.Z()),
                                                       Vector3(h1.X(), h1.Y(), h1.Z()),
                                                       Vector3(h2.X(), h2.Y(), h2.Z())));
                childCluster->_cvPlaneDrawables.push_back(Plane3Drawable<Vec3Types::Real>(childCluster->_cvPlanes.back()));

                Vector3 corner0(h0.X(), h0.Y(), h0.Z());
                Vector3 corner1(h1.X(), h1.Y(), h1.Z());
                Vector3 corner2(h2.X(), h2.Y(), h2.Z());

                Vector3 triCentroid((corner0.x() + corner1.x() + corner2.x()) / 3.0f,
                                    (corner0.y() + corner1.y() + corner2.y()) / 3.0f,
                                    (corner0.z() + corner1.z() + corner2.z()) / 3.0f);

                childCluster->_cvPlaneDrawables.back().setPlaneOrigin(triCentroid);
                std::cout << "   centroid: " << triCentroid << std::endl;
            }

            /*std::cout << "Planes for convex hull of cluster " << childCluster->getName() << ": " << childCluster->_cvPlanes.size() << std::endl;
            for (int k = 0; k < childCluster->_cvPlanes.size(); k++)
            {
                std::cout << " * " << childCluster->_cvPlanes[k] << std::endl;
            }*/

            std::cout << "Triangle associations" << std::endl;

            int numInside = 0, numOutside = 0;
            sofa::helper::vector<std::pair<unsigned int, sofa::component::topology::BaseMeshTopology::Triangle> > clusterTriangles;
            sofa::helper::vector<unsigned int> clusterTriangleIndices;
            for (int m = 0; m < meshTriangles.size(); m++)
            {
                sofa::component::topology::MeshTopology::Triangle tri = meshTriangles[m];
                std::cout << " - triangle " << m << "(" << tri[0] << "," << tri[1] << "," << tri[2] << "): " /*<< std::endl*/;

                Vector3 c0 = meshPoints[tri[0]];
                Vector3 c1 = meshPoints[tri[1]];
                Vector3 c2 = meshPoints[tri[2]];
                bool c0in = true, c1in = true, c2in = true;
                for (int n = 0; n < childCluster->_cvPlanes.size(); n++)
                {
                    Plane3D<Vec3Types::Real>& cvPlane = childCluster->_cvPlanes[n];
                    // std::cout << "    Plane " << n << ": ";
                    if (cvPlane.pointOnWhichSide(c0) == Plane3D<Vec3Types::Real>::AWAY_FROM_NORMAL)
                    {
                        // std::cout << "c0 inside: " << cvPlane.distanceToPoint(c0) << ",";
                    }
                    else
                    {
                        c0in = false;
                        // std::cout << "c0 outside: " << cvPlane.distanceToPoint(c0) << ",";
                    }

                    if (cvPlane.pointOnWhichSide(c1) == Plane3D<Vec3Types::Real>::AWAY_FROM_NORMAL)
                    {
                        // std::cout << "c1 inside: " << cvPlane.distanceToPoint(c1) << ",";
                    }
                    else
                    {
                        c1in = false;
                        // std::cout << "c1 outside: " << cvPlane.distanceToPoint(c1) << ",";
                    }

                    if (cvPlane.pointOnWhichSide(c2) == Plane3D<Vec3Types::Real>::AWAY_FROM_NORMAL)
                    {
                        // std::cout << "c2 inside: " << cvPlane.distanceToPoint(c2);
                    }
                    else
                    {
                        c2in = false;
                        // std::cout << "c2 outside: " << cvPlane.distanceToPoint(c2);
                    }
                    // std::cout << std::endl;
                }
                // std::cout << " in/out " << c0in << "," << c1in << "," << c2in << std::endl;
                if (c0in && c1in && c2in)
                {
                    std::cout << "INSIDE cluster " << childCluster->getName() << std::endl;
                    numInside++;
                    clusterTriangles.push_back(std::make_pair(m,tri));
                    clusterTriangleIndices.push_back(m);
                }
                else
                {
                    std::cout << "OUTSIDE cluster " << childCluster->getName() << std::endl;
                    numOutside++;
                }
            }
            std::cout << " cluster " << childCluster->getName() << ": " << numInside << " inside, " << numOutside << " outside." << std::endl;
            childCluster->setTriangleIndices(clusterTriangles);

            ReadAccessor<Data<VecPointMask> > pointMasks(_pointGrids);
            ReadAccessor<Data<VecPointMaskOrigin> > gridOrigins(_pointGridOrigins);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeX(_pointGridSizeX);
            ReadAccessor<Data<VecPointMaskDiagonal> > gridSizeY(_pointGridSizeY);

            std::cout << " copy surface point masks to cluster: " << " point mask count = " << pointMasks.size() << ", triangle indices count = " << clusterTriangleIndices.size() << std::endl;
            for (int p = 0; p < clusterTriangleIndices.size(); p++)
            {
                std::cout << "  * index " << clusterTriangleIndices[p] << ": ";
                Vec<4, long> pm = pointMasks[clusterTriangleIndices[p]];
                for (int q = 0; q < 4; q++)
                    std::cout << pm[q] << ";";

                std::cout << std::endl;

                childCluster->_pointMasks.push_back(pm);
                childCluster->_pointMaskOrigins.push_back(gridOrigins[clusterTriangleIndices[p]]);
                childCluster->_pointMaskSizeX.push_back(gridSizeX[clusterTriangleIndices[p]]);
                childCluster->_pointMaskSizeY.push_back(gridSizeY[clusterTriangleIndices[p]]);
            }

            int minFacetIdx = -1, maxFacetIdx = -1;
            int facetIdx;
            for (int p = 0; p < clusterTriangleIndices.size(); p++)
            {
                facetIdx = clusterTriangleIndices[p];
                childCluster->_childFacets.push_back(facetIdx);

                if (minFacetIdx == -1 && facetIdx >= 0)
                {
                    //std::cout << "  setting initial min facet index: " << facetIdx << std::endl;
                    minFacetIdx = facetIdx;
                }
                if (maxFacetIdx == -1 && facetIdx >= 0)
                {
                    //std::cout << "  setting initial max facet index: " << facetIdx << std::endl;
                    maxFacetIdx = facetIdx;
                }

                if (facetIdx < minFacetIdx)
                {
                    //std::cout << "  setting new min facet index: " << facetIdx << std::endl;
                    minFacetIdx = facetIdx;
                }
                if (facetIdx > maxFacetIdx)
                {
                    //std::cout << "  setting new max facet index: " << facetIdx << std::endl;
                    maxFacetIdx = facetIdx;
                }
            }

            /// ACHTUNG: Nicht konsistent numeriert! Verwendet stattdessen LGCPointCluster::_childFacets
            std::cout << " facet range for cluster " << childCluster->getName() << ": " << minFacetIdx << " - " << maxFacetIdx << std::endl;
            childCluster->_facetRangeMin = minFacetIdx;
            childCluster->_facetRangeMax = maxFacetIdx;
            childCluster->_facetRangeAdjusted = true;

            childCluster->buildSubCluster();
        }
    }
}
