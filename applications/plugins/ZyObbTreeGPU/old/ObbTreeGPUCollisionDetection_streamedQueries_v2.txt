#include "ObbTreeGPUCollisionDetection.h"

#include <PQP/src/MatVec.h>
#include <PQP/src/GetTime.h>
#include <PQP/include/PQP.h>
#include <PQP/include/BV.h>

#include <sofa/core/ObjectFactory.h>
#include <sofa/component/topology/MeshTopology.h>
#include <sofa/core/visual/DrawTool.h>
#include <sofa/core/visual/DrawToolGL.h>

#include <sofa/component/collision/DiscreteIntersection.h>
#include <sofa/core/collision/Contact.h>
#include <sofa/component/collision/BaseContactMapper.h>
#include <sofa/component/collision/BarycentricPenalityContact.h>

#include <sofa/component/container/MechanicalObject.h>

#include <GL/gl.h>

#include <boost/algorithm/string/iter_find.hpp>
#include <boost/algorithm/string/finder.hpp>

#include "ObbTreeGPUIntersection.h"

#include <cuda.h>
#include <cuda_runtime.h>
#include <driver_types.h>
#include <cuda_runtime_api.h>

#include <cutil/cutil.h>

#include "ObbTreeGPU_CudaDataStructures.h"
#include "ObbTreeGPUTriangleCollision_cuda.h"

#include "ObbTreeGPUCollisionModel_cuda.h"

#include <thrust_v180/host_vector.h>

struct gProximityWorkerResultPrivate
{
    thrust::host_vector<int, std::allocator<int> > h_contactId;
    thrust::host_vector<double, std::allocator<double> > h_distance;
    thrust::host_vector<int4, std::allocator<int4> > h_elems;
    thrust::host_vector<float3, std::allocator<float3> > h_point0;
    thrust::host_vector<float3, std::allocator<float3> > h_point1;
    thrust::host_vector<float3, std::allocator<float3> > h_normal;
    thrust::host_vector<gProximityContactType, std::allocator<gProximityContactType> > h_gProximityContactType;
};

using namespace sofa::component::collision;
using namespace sofa;
using namespace sofa::component::container;

SOFA_DECL_CLASS(ObbTreeGPUCollisionDetection)

int ObbTreeGPUCollisionDetectionClass = sofa::core::RegisterObject("Collision detection using GPU-based OBB-trees, with fall back to brute-force pair tests")
.add< ObbTreeGPUCollisionDetection >();

//sofa::helper::Creator<sofa::core::collision::Contact::Factory, sofa::component::collision::BarycentricPenalityContact<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types>, Vec3fTypes> > ObbTreeGPUContactClass("default", true);


ObbTreeGPUCollisionDetection::ObbTreeGPUCollisionDetection():
    BruteForceDetection(),
    m_intersection(NULL),
    _updateGPUVertexPositions(initData(&_updateGPUVertexPositions, false, "updateGPUVertexPositions", "Update GPU vertex arrays in beginNarrowPhase", true, false)),
    _useStreamedCollisionQueries(initData(&_useStreamedCollisionQueries, false, "useStreamedCollisionQueries", "Use CUDA streams to further parallelize collision queries", true, false)),
    _useDynamicWorkerScheme(initData(&_useDynamicWorkerScheme, false, "useDynamicWorkerScheme", "Use dynamically sized/allocated worker result bins", true, false)),
    _numStreamedWorkerUnits(initData(&_numStreamedWorkerUnits, (unsigned int) 4, "numStreamedWorkerUnits", "Use CUDA streams to further parallelize collision queries", true, false)),
    _numStreamedWorkerResultBins(initData(&_numStreamedWorkerResultBins, (unsigned int) 4, "numStreamedWorkerResultBins", "Use CUDA streams to further parallelize collision queries", true, false)),
    _streamedWorkerResultMinSize(initData(&_streamedWorkerResultMinSize, (unsigned int) 4096, "streamedWorkerResultMinSize", "Use CUDA streams to further parallelize collision queries", true, false)),
    _streamedWorkerResultMaxSize(initData(&_streamedWorkerResultMaxSize, (unsigned int) 32768, "streamedWorkerResultMaxSize", "Use CUDA streams to further parallelize collision queries", true, false))
{

}

ObbTreeGPUCollisionDetection::~ObbTreeGPUCollisionDetection()
{
#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    if (_useDynamicWorkerScheme.getValue())
    {
        CUDA_SAFE_CALL(cudaStreamDestroy(_transformStream));

        for (unsigned int k = 0; k < _obbTreeGPUModels.size(); k++)
        {
            delete _gpuTransforms[k];
        }
        delete [] _gpuTransforms;

        /*for (std::map<std::string, gProximityGPUTransform*>::iterator it = _modelTransforms.begin(); it != _modelTransforms.end(); it++)
        {
            delete it->second;
        }
        _modelTransforms.clear();*/

        std::cout << "ObbTreeGPUCollisionDetection::~ObbTreeGPUCollisionDetection(" << this->getName() << ")" << std::endl;
        std::cout << " destroy tri-test streams" << std::endl;
        for (unsigned int k = 0; k < _numStreamedWorkerResultBins.getValue(); k++)
        {
            CUDA_SAFE_CALL(cudaStreamDestroy(_triTestStreams[k]));
        }

        std::cout << " de-allocate streamed worker units: " << _streamedWorkerUnits.size() << std::endl;
        for (unsigned int k = 0; k < _streamedWorkerUnits.size(); k++)
        {
            gProximityWorkerUnit* workerUnit = _streamedWorkerUnits[k];
            if (workerUnit != NULL)
            {
                CUDA_SAFE_CALL(cudaStreamDestroy(_workerStreams[k]));
                delete workerUnit;
            }
        }
        _streamedWorkerUnits.clear();

        std::cout << " de-allocate streamed worker results: " << _streamedWorkerResults.size() << std::endl;
        for (std::map<unsigned int, std::vector<gProximityWorkerResult*> >::iterator it = _streamedWorkerResults.begin(); it != _streamedWorkerResults.end(); it++)
        {
            std::vector<gProximityWorkerResult*>& workerResults = it->second;
            for (unsigned int k = 0; k < workerResults.size(); k++)
            {
                delete workerResults[k];
            }
            workerResults.clear();
        }

        _streamedWorkerResults.clear();
    }
    /*else
    {
        for (unsigned int k = 0; k < 4; k++)
        {
            CUDA_SAFE_CALL(cudaStreamDestroy(m_workerStreams[k]));

            delete m_gProximityWorkerUnits[k];

            delete m_gProximityWorkerResults_64[k];
            delete m_gProximityWorkerResults_128[k];
            delete m_gProximityWorkerResults_256[k];
        }
    }*/
#endif
}

void ObbTreeGPUCollisionDetection::reset()
{

    for (std::map<std::string, std::pair<GPUVertex*, GPUVertex*> >::iterator it = m_transformedVertices.begin(); it != m_transformedVertices.end(); it++)
    {
        if (it->second.first)
            delete[] it->second.first;

        if (it->second.second)
            delete[] it->second.second;
    }

    m_transformedVertices.clear();
}

void ObbTreeGPUCollisionDetection::init()
{
    int deviceCount;
    cudaGetDeviceCount(&deviceCount);
    int device;
    for (device = 0; device < deviceCount; ++device)
    {
        cudaDeviceProp deviceProp;
        cudaGetDeviceProperties(&deviceProp, device);
        printf("Device %d has compute capability %d.%d. Supports concurrent kernel execution = %d; asyncEngineCount = %d\n",
               device, deviceProp.major, deviceProp.minor, deviceProp.concurrentKernels, deviceProp.asyncEngineCount);
    }

    BruteForceDetection::init();

    std::vector<sofa::component::collision::OBBTreeGPUDiscreteIntersection* > moV;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::collision::OBBTreeGPUDiscreteIntersection, std::vector<sofa::component::collision::OBBTreeGPUDiscreteIntersection* > > cb(&moV);

    getContext()->getObjects(TClassInfo<sofa::component::collision::OBBTreeGPUDiscreteIntersection>::get(), cb, TagSet(), BaseContext::SearchRoot);

    std::cout << "ObbTreeGPUCollisionDetection::init(): Searched for instances of OBBTreeGPUDiscreteIntersection; found = " << moV.size() << std::endl;
    if (moV.size() == 1)
    {
        //std::cout << " Using: " << moV.begin()->getName() << " of type " << moV.begin()->getTypeName() << std::endl;
        m_intersection = moV[0];
    }

#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    m_numOBBTreePairsTested = 0;
    for (unsigned short k = 0; k < 4; k++)
    {
        m_workerResultOccupied_64[k] = false;
        m_workerResultOccupied_128[k] = false;
        m_workerResultOccupied_256[k] = false;

        m_workerUnitOccupied[k] = false;
    }
#endif
}

void ObbTreeGPUCollisionDetection::reinit()
{
    BruteForceDetection::reinit();
    m_obbModels.clear();
    m_pqpModels.clear();

    for (std::map<std::string, std::pair<GPUVertex*, GPUVertex*> >::iterator it = m_transformedVertices.begin(); it != m_transformedVertices.end(); it++)
    {
        if (it->second.first)
            delete[] it->second.first;

        if (it->second.second)
            delete[] it->second.second;
    }

    m_transformedVertices.clear();
#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    m_numOBBTreePairsTested = 0;
    for (unsigned short k = 0; k < 4; k++)
    {
        m_workerResultOccupied_64[k] = false;
        m_workerResultOccupied_128[k] = false;
        m_workerResultOccupied_256[k] = false;

        m_workerUnitOccupied[k] = false;

    }
#endif
}

void ObbTreeGPUCollisionDetection::bwdInit()
{
#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    if (_useDynamicWorkerScheme.getValue())
    {
        CUDA_SAFE_CALL(cudaStreamCreate(&_transformStream));

        std::vector<sofa::component::collision::ObbTreeGPUCollisionModel<Vec3Types>* > obbTreeGPUCollisionModels;
        sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<sofa::component::collision::ObbTreeGPUCollisionModel<Vec3Types>, std::vector<sofa::component::collision::ObbTreeGPUCollisionModel<Vec3Types>* > > obbTreeGPUCollisionModels_cb(&obbTreeGPUCollisionModels);
        getContext()->getObjects(TClassInfo<sofa::component::collision::ObbTreeGPUCollisionModel<Vec3Types> >::get(), obbTreeGPUCollisionModels_cb, TagSet(), BaseContext::SearchRoot);

        if (obbTreeGPUCollisionModels.size() > 0)
        {
            _gpuTransforms = new gProximityGPUTransform*[obbTreeGPUCollisionModels.size()];

            std::cout << "ObbTreeGPUCollisionDetection::init(): Searched for instances of OBBTreeGPUCollisionModel; found = " << obbTreeGPUCollisionModels.size() << std::endl;
            for (unsigned int k = 0; k < obbTreeGPUCollisionModels.size(); k++)
            {
                _gpuTransforms[k] = new gProximityGPUTransform();

                std::cout << " * " << k << ": " << obbTreeGPUCollisionModels[k]->getName() << std::endl;
                std::cout << "   store in model map" << std::endl;
                //_modelTransforms.insert(std::make_pair(obbTreeGPUCollisionModels[k]->getName(), new gProximityGPUTransform()));
                _obbTreeGPUModels.insert(std::make_pair(obbTreeGPUCollisionModels[k]->getName(), obbTreeGPUCollisionModels[k]));

                Vector3 modelPosition = obbTreeGPUCollisionModels[k]->getCachedModelPosition();
                Matrix3 modelOrientation = obbTreeGPUCollisionModels[k]->getCachedModelOrientation();

                float3 h_modelPosition = make_float3(modelPosition.x(), modelPosition.y(), modelPosition.z());
                Matrix3x3_d h_modelOrientation;

                h_modelOrientation.m_row[0].x = modelOrientation(0,0);
                h_modelOrientation.m_row[0].y = modelOrientation(0,1);
                h_modelOrientation.m_row[0].z = modelOrientation(0,2);
                h_modelOrientation.m_row[1].x = modelOrientation(1,0);
                h_modelOrientation.m_row[1].y = modelOrientation(1,1);
                h_modelOrientation.m_row[1].z = modelOrientation(1,2);
                h_modelOrientation.m_row[2].x = modelOrientation(2,0);
                h_modelOrientation.m_row[2].y = modelOrientation(2,1);
                h_modelOrientation.m_row[2].z = modelOrientation(2,2);

                std::cout << "     model " << obbTreeGPUCollisionModels[k]->getName() << " position    = " << h_modelPosition.x << "," << h_modelPosition.y << "," << h_modelPosition.z << std::endl;
                std::cout << "                                                             orientation = [" << h_modelOrientation.m_row[0].x << "," << h_modelOrientation.m_row[0].y << "," << h_modelOrientation.m_row[0].z << "],[" << h_modelOrientation.m_row[1].x << "," << h_modelOrientation.m_row[1].y << "," << h_modelOrientation.m_row[1].z << "],[" << h_modelOrientation.m_row[2].x << "," << h_modelOrientation.m_row[2].y << "," << h_modelOrientation.m_row[2].z << "]"<< std::endl;

                std::cout << "   Initial position upload to GPU memory" << std::endl;

                gProximityGPUTransform* gpTransform = _gpuTransforms[k];

                TOGPU(gpTransform->modelTranslation, &h_modelPosition, sizeof(float3));
                TOGPU(gpTransform->modelOrientation, &h_modelOrientation, sizeof(Matrix3x3_d));

                float3 h_modelPosition_Reread;
                Matrix3x3_d h_modelOrientation_Reread;

                FROMGPU(&h_modelPosition_Reread, gpTransform->modelTranslation, sizeof(float3));
                std::cout << "   position re-read_2: " << h_modelPosition_Reread.x << "," << h_modelPosition_Reread.y << "," << h_modelPosition_Reread.z << std::endl;

                FROMGPU(&h_modelOrientation_Reread, gpTransform->modelOrientation, sizeof(Matrix3x3_d));
                std::cout << "   orientation re-read_2: [" << h_modelOrientation_Reread.m_row[0].x << "," << h_modelOrientation_Reread.m_row[0].y << "," << h_modelOrientation_Reread.m_row[0].z << "],[" << h_modelOrientation_Reread.m_row[1].x << "," << h_modelOrientation_Reread.m_row[1].y << "," << h_modelOrientation_Reread.m_row[1].z << "],[" << h_modelOrientation_Reread.m_row[2].x << "," << h_modelOrientation_Reread.m_row[2].y << "," << h_modelOrientation_Reread.m_row[2].z << "]"<< std::endl;

                _gpuTransformIndices.insert(std::make_pair(obbTreeGPUCollisionModels[k]->getName(), k));
            }
        }

        std::cout << "ObbTreeGPUCollisionDetection::bwdInit(" << this->getName() << ")" << std::endl;

        if (_useDynamicWorkerScheme.getValue())
        {
            std::cout << " allocate streamed worker units: " << _numStreamedWorkerUnits.getValue() << std::endl;
            _workerStreams.resize(_numStreamedWorkerUnits.getValue());
            for (unsigned int k = 0; k < _numStreamedWorkerUnits.getValue(); k++)
            {
                gProximityWorkerUnit* workerUnit = new gProximityWorkerUnit();
                CUDA_SAFE_CALL(cudaStreamCreate(&(_workerStreams[k])));
                workerUnit->_stream = &(_workerStreams[k]);
                _streamedWorkerUnits.push_back(workerUnit);
            }

            _triTestStreams.resize(_numStreamedWorkerResultBins.getValue());
            for (unsigned int k = 0; k < _numStreamedWorkerResultBins.getValue(); k++)
            {
                CUDA_SAFE_CALL(cudaStreamCreate(&(_triTestStreams[k])));
            }

            std::cout << " allocate streamed worker results: " << _numStreamedWorkerResultBins.getValue() << std::endl;
            for (unsigned int k = 0; k < _numStreamedWorkerResultBins.getValue(); k++)
            {
                _streamedWorkerResults.insert(std::make_pair(k, std::vector<gProximityWorkerResult*>()));
            }

            std::cout << "ObbTreeGPUCollisionDetection(" << this->getName() << "): _numStreamedWorkerResultBins = "
                      << _numStreamedWorkerResultBins.getValue() << "; _streamedWorkerResultMinSize = " << _streamedWorkerResultMinSize.getValue()
                      << "; _streamedWorkerResultMaxSize = " << _streamedWorkerResultMaxSize.getValue() << std::endl;
            unsigned int minMaxRatio = _streamedWorkerResultMaxSize.getValue() / _streamedWorkerResultMinSize.getValue();
            unsigned int curBinSize = _streamedWorkerResultMinSize.getValue();
            for (unsigned int k = 0; k < _numStreamedWorkerResultBins.getValue(); k++)
            {
                unsigned int numResultUnitsForBin = _numStreamedWorkerResultBins.getValue() * minMaxRatio;
                std::cout << "  bin level " << k << ": curBinSize = " << curBinSize << ", minMaxRatio = " << minMaxRatio << ", numResultUnitsForBin = " << numResultUnitsForBin << std::endl;
                for (unsigned int l = 0; l < numResultUnitsForBin; l++)
                {
                    _streamedWorkerResults[k].push_back(new gProximityWorkerResult(curBinSize));
                }

                minMaxRatio /= 2;
                curBinSize *= 2;
            }
        }
    }
    /*else
    {
        for (unsigned int k = 0; k < 4; k++)
        {
            CUDA_SAFE_CALL(cudaStreamCreate(&m_workerStreams[k]));
            m_gProximityWorkerUnits[k] = new gProximityWorkerUnit();
            m_gProximityWorkerUnits[k]->_stream = &m_workerStreams[k];

            m_resultBinSize1 = 2048;
            m_resultBinSize2 = 4096;
            m_resultBinSize3 = 262144;

            m_gProximityWorkerResults_64[k] = new gProximityWorkerResult(m_resultBinSize1);
            m_gProximityWorkerResults_128[k] = new gProximityWorkerResult(m_resultBinSize2);
            m_gProximityWorkerResults_256[k] = new gProximityWorkerResult(m_resultBinSize3);

            m_workerResultOccupied_64[k] = false;
            m_workerResultOccupied_128[k] = false;
            m_workerResultOccupied_256[k] = false;
            m_workerUnitOccupied[k] = false;
        }
    }*/
    m_numOBBTreePairsTested = 0;
#endif


    std::vector<ObbTreeGPULocalMinDistance* > lmdNodes;
    sofa::core::objectmodel::BaseContext::GetObjectsCallBackT<ObbTreeGPULocalMinDistance, std::vector<ObbTreeGPULocalMinDistance* > > cb(&lmdNodes);

    getContext()->getObjects(TClassInfo<ObbTreeGPULocalMinDistance>::get(), cb, TagSet(), BaseContext::SearchRoot);

    std::cout << "ObbTreeGPUCollisionDetection::bwdInit(): ObbTreeGPULocalMinDistance instances found: " << lmdNodes.size() << std::endl;
    if (lmdNodes.size() > 0)
    {
        std::cout << " alarmDistance = " << lmdNodes.at(0)->getAlarmDistance() << ", contactDistance = " << lmdNodes.at(0)->getContactDistance() << std::endl;
        m_alarmDistance = lmdNodes.at(0)->getAlarmDistance();
        m_contactDistance = lmdNodes.at(0)->getContactDistance();
    }
    else
    {
        m_alarmDistance = 0.25f;
        m_contactDistance = 0.125f;
    }
}

//#define OBBTREEGPUCOLLISIONDETECTION_BEGINBROADPHASE_DEBUG
void ObbTreeGPUCollisionDetection::beginBroadPhase()
{
#ifdef OBBTREEGPUCOLLISIONDETECTION_BEGINBROADPHASE_DEBUG
    sout << "=== ObbTreeGPUCollisionDetection::beginBroadPhase() ===" << sendl;
#endif
    m_intersectingOBBs.clear();
    m_intersectingTriangles.clear();

    //m_testedModelPairs_AB.clear();
    //m_testedModelPairs_BA.clear();

    m_testedModelPairs.clear();

    for (std::map<std::string, std::pair<GPUVertex*, GPUVertex*> >::iterator it = m_transformedVertices.begin(); it != m_transformedVertices.end(); it++)
    {
        if (it->second.first)
            delete[] it->second.first;

        if (it->second.second)
            delete[] it->second.second;
    }

    m_transformedVertices.clear();
#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    m_numOBBTreePairsTested = 0;
    for (unsigned short k = 0; k < 4; k++)
    {
        m_workerResultOccupied_64[k] = false;
        m_workerResultOccupied_128[k] = false;
        m_workerResultOccupied_256[k] = false;

        m_workerUnitOccupied[k] = false;
    }

    _narrowPhasePairs.clear();
#endif
    BruteForceDetection::beginBroadPhase();
}

//#define OBBTREEGPUCOLLISIONDETECTION_ENDBROADPHASE_DEBUG
void ObbTreeGPUCollisionDetection::endBroadPhase()
{
#ifdef OBBTREEGPUCOLLISIONDETECTION_ENDBROADPHASE_DEBUG
    sout << "ObbTreeGPUCollisionDetection::endBroadPhase()" << sendl;
#endif
#ifdef OBBTREE_GPU_STREAMED_COLLISION_QUERIES
    m_numOBBTreePairsTested = 0;
    for (unsigned short k = 0; k < 4; k++)
    {
        m_workerResultOccupied_64[k] = false;
        m_workerResultOccupied_128[k] = false;
        m_workerResultOccupied_256[k] = false;

        m_workerUnitOccupied[k] = false;
    }
#endif
    BruteForceDetection::endBroadPhase();
}

#define OBBTREEGPU_COLLISION_DETECTION_BEGIN_NARROW_PHASE_DEBUG
void ObbTreeGPUCollisionDetection::beginNarrowPhase()
{
    std::cout << "=== ObbTreeGPUCollisionDetection::beginNarrowPhase() ===" << std::endl;
    BruteForceDetection::beginNarrowPhase();

    if (_updateGPUVertexPositions.getValue())
    {
        for (std::map<std::string, ObbTreeGPUCollisionModel<Vec3Types>*>::iterator it = _obbTreeGPUModels.begin(); it != _obbTreeGPUModels.end(); it++)
        {
            ObbTreeGPUCollisionModel<Vec3Types>* cm = it->second;
            //gProximityGPUTransform* mt = it->second;

            Vector3 modelPosition = cm->getCachedModelPosition();
            Matrix3 modelOrientation = cm->getCachedModelOrientation();

            bool skipPositionUpdate = false;
            if (!cm->isSimulated() || !cm->isMoving())
            {
    #ifdef OBBTREEGPU_COLLISION_DETECTION_BEGIN_NARROW_PHASE_DEBUG
                std::cout << " EXCEPTION HANDLING FOR STATIC COLLISION MODEL " << cm->getName() << std::endl;
    #endif
                {
                    MechanicalObject<Vec3Types>* mob = dynamic_cast<MechanicalObject<Vec3Types>*>(cm->getMechanicalState());
                    if (mob)
                    {
                        modelPosition = Vector3(mob->getPosition()[0][0], mob->getPosition()[0][1], mob->getPosition()[0][2]);
                        Quaternion modelRotation(mob->getPosition()[0][3], mob->getPosition()[0][4], mob->getPosition()[0][5], mob->getPosition()[0][6]);
                        modelRotation.toMatrix(modelOrientation);
    #ifdef OBBTREEGPU_COLLISION_DETECTION_BEGIN_NARROW_PHASE_DEBUG
                        std::cout << " position = " << modelPosition << std::endl;
                        std::cout << " orientation = " << modelOrientation << std::endl;
    #endif
                    }
                    else
                    {
                        skipPositionUpdate = true;
                        std::cout << "WARNING: SKIP position update for model " << cm->getName() << " (no position query possible from its MechanicalState); please check its definition in the SOFA scene for correctness!" << std::endl;
                    }
                }
            }

            /*if (mt == NULL)
            {
                skipPositionUpdate = true;
                std::cout << "WARNING: SKIP position update for model " << cm->getName() << " (GPU model transform data structure not allocated); please check its definition in the SOFA scene for correctness!" << std::endl;
            }*/

            if (!skipPositionUpdate)
            {
                float3 h_modelPosition = make_float3(modelPosition.x(), modelPosition.y(), modelPosition.z());
                Matrix3x3_d h_modelOrientation;

                h_modelOrientation.m_row[0].x = modelOrientation(0,0);
                h_modelOrientation.m_row[0].y = modelOrientation(0,1);
                h_modelOrientation.m_row[0].z = modelOrientation(0,2);
                h_modelOrientation.m_row[1].x = modelOrientation(1,0);
                h_modelOrientation.m_row[1].y = modelOrientation(1,1);
                h_modelOrientation.m_row[1].z = modelOrientation(1,2);
                h_modelOrientation.m_row[2].x = modelOrientation(2,0);
                h_modelOrientation.m_row[2].y = modelOrientation(2,1);
                h_modelOrientation.m_row[2].z = modelOrientation(2,2);

                std::cout << " * model " << cm->getName() << " position    = " << h_modelPosition.x << "," << h_modelPosition.y << "," << h_modelPosition.z << std::endl;
                std::cout << "                                 orientation = [" << h_modelOrientation.m_row[0].x << "," << h_modelOrientation.m_row[0].y << "," << h_modelOrientation.m_row[0].z << "],[" << h_modelOrientation.m_row[1].x << "," << h_modelOrientation.m_row[1].y << "," << h_modelOrientation.m_row[1].z << "],[" << h_modelOrientation.m_row[2].x << "," << h_modelOrientation.m_row[2].y << "," << h_modelOrientation.m_row[2].z << "]"<< std::endl;

                //std::cout << "   mt struct for " << cm->getName() << " = " << mt << std::endl;

                /*TOGPU_ASYNC(mt->modelTranslation, &h_modelPosition, sizeof(float3), _transformStream);
                TOGPU_ASYNC(mt->modelOrientation, &h_modelOrientation, sizeof(Matrix3x3_d), _transformStream);*/

                //TOGPU(mt->modelTranslation, &h_modelPosition, sizeof(float3));
                //TOGPU(mt->modelOrientation, &h_modelOrientation, sizeof(Matrix3x3_d));
        /*#ifdef OBBTREEGPU_COLLISION_DETECTION_BEGIN_NARROW_PHASE_DEBUG
                float3 h_modelPosition_Reread;
                FROMGPU(&h_modelPosition_Reread, mt->modelTranslation, sizeof(float3));
                std::cout << "   position re-read_1: " << h_modelPosition_Reread.x << "," << h_modelPosition_Reread.y << "," << h_modelPosition_Reread.z << std::endl;

                Matrix3x3_d h_modelOrientation_Reread;
                FROMGPU(&h_modelOrientation_Reread, mt->modelOrientation, sizeof(Matrix3x3_d));
                std::cout << "   orientation re-read_1: [" << h_modelOrientation_Reread.m_row[0].x << "," << h_modelOrientation_Reread.m_row[0].y << "," << h_modelOrientation_Reread.m_row[0].z << "],[" << h_modelOrientation_Reread.m_row[1].x << "," << h_modelOrientation_Reread.m_row[1].y << "," << h_modelOrientation_Reread.m_row[1].z << "],[" << h_modelOrientation_Reread.m_row[2].x << "," << h_modelOrientation_Reread.m_row[2].y << "," << h_modelOrientation_Reread.m_row[2].z << "]"<< std::endl;
        #endif*/

                /*TOGPU_ASYNC(_gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelTranslation, &h_modelPosition, sizeof(float3), _transformStream);
                TOGPU_ASYNC(_gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelOrientation, &h_modelOrientation, sizeof(Matrix3x3_d), _transformStream);*/

                std::cout << "gpuTransforms update: " << cm->getName() << "WARUM CRASH HIER???" << std::endl;
                TOGPU(_gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelTranslation, &h_modelPosition, sizeof(float3));
                TOGPU(_gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelOrientation, &h_modelOrientation, sizeof(Matrix3x3_d));

        #ifdef OBBTREEGPU_COLLISION_DETECTION_BEGIN_NARROW_PHASE_DEBUG

                float3 h_modelPosition_Reread;
                Matrix3x3_d h_modelOrientation_Reread;

                FROMGPU(&h_modelPosition_Reread, _gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelTranslation, sizeof(float3));
                std::cout << "   position re-read_2: " << h_modelPosition_Reread.x << "," << h_modelPosition_Reread.y << "," << h_modelPosition_Reread.z << std::endl;

                FROMGPU(&h_modelOrientation_Reread, _gpuTransforms[_gpuTransformIndices[cm->getName()]]->modelOrientation, sizeof(Matrix3x3_d));
                std::cout << "   orientation re-read_2: [" << h_modelOrientation_Reread.m_row[0].x << "," << h_modelOrientation_Reread.m_row[0].y << "," << h_modelOrientation_Reread.m_row[0].z << "],[" << h_modelOrientation_Reread.m_row[1].x << "," << h_modelOrientation_Reread.m_row[1].y << "," << h_modelOrientation_Reread.m_row[1].z << "],[" << h_modelOrientation_Reread.m_row[2].x << "," << h_modelOrientation_Reread.m_row[2].y << "," << h_modelOrientation_Reread.m_row[2].z << "]"<< std::endl;
        #endif
                updateInternalGeometry_cuda_streamed(cm->getModelInstance(), (GPUVertex*) cm->getTransformedVerticesPtr(), _gpuTransforms[_gpuTransformIndices[cm->getName()]], _transformStream, cm->hasModelPositionChanged());
            }
        }
        cudaStreamSynchronize(_transformStream);
    }

    _narrowPhasePairs.clear();
}

#define OBBTREEGPU_COLLISION_DETECTION_END_NARROW_PHASE_DEBUG
void ObbTreeGPUCollisionDetection::endNarrowPhase()
{
#ifdef OBBTREEGPU_COLLISION_DETECTION_END_NARROW_PHASE_DEBUG
    std::cout << "=== ObbTreeGPUCollisionDetection::endNarrowPhase(" << this->getName() << ") ===" << std::endl;
    std::cout << " OBB tree pairs to check = " << _narrowPhasePairs.size() << std::endl;
    for (int k = 0; k < _narrowPhasePairs.size(); k++)
    {
        ObbTreeGPUCollisionModel<Vec3Types>* obbModel1 = _narrowPhasePairs[k].first._obbCollisionModel;
        ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = _narrowPhasePairs[k].second._obbCollisionModel;
        std::cout << "  - check: " << obbModel1->getName() << " - " << obbModel2->getName() << std::endl;
    }

#endif

    if (_useDynamicWorkerScheme.getValue())
    {
        int numThreads = _numStreamedWorkerUnits.getValue();

        unsigned int numIterations;
        if (_narrowPhasePairs.size() < _numStreamedWorkerUnits.getValue())
            numIterations = 1;
        else
            numIterations = (_narrowPhasePairs.size() / _numStreamedWorkerUnits.getValue()) + 1;

        std::cout << "ITERATIONS FOR COLLISION CHECKS: " << numIterations << std::endl;

        for (unsigned int i = 0; i < numIterations; i++)
        {
            std::vector<int> intersectingTriPairCount;
            intersectingTriPairCount.resize(numThreads);

            std::cout << " iteration " << i << std::endl;

            //#pragma omp parallel for num_threads(numThreads)
            for (unsigned int k = 0; k < numThreads; k++)
            {
                int pairCheckIdx = (i * _numStreamedWorkerUnits.getValue()) + k;
                std::cout << "  pair check " << pairCheckIdx << std::endl;
                if (pairCheckIdx < _narrowPhasePairs.size())
                {
                    OBBContainer& obbTree1 = _narrowPhasePairs[pairCheckIdx].first._obbContainer;
                    OBBContainer& obbTree2 = _narrowPhasePairs[pairCheckIdx].second._obbContainer;

                    ObbTreeGPUCollisionModel<Vec3Types>* obbModel1 = _narrowPhasePairs[pairCheckIdx].first._obbCollisionModel;
                    ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = _narrowPhasePairs[pairCheckIdx].second._obbCollisionModel;

#ifdef OBBTREEGPU_COLLISION_DETECTION_END_NARROW_PHASE_DEBUG
                    std::cout << " - CHECKED OBB MODEL PAIR: " << obbModel1->getName() << " - " << obbModel2->getName() << std::endl;
#endif
                    gProximityGPUTransform* modelTr1 = _gpuTransforms[_gpuTransformIndices[obbModel1->getName()]];
                    gProximityGPUTransform* modelTr2 = _gpuTransforms[_gpuTransformIndices[obbModel2->getName()]];

#ifdef OBBTREEGPU_COLLISION_DETECTION_END_NARROW_PHASE_DEBUG
                    float3 h_modelPosition_Reread1;
                    float3 h_modelPosition_Reread2;
                    FROMGPU(&h_modelPosition_Reread1, modelTr1->modelTranslation, sizeof(float3));
                    FROMGPU(&h_modelPosition_Reread2, modelTr2->modelTranslation, sizeof(float3));

                    std::cout << "   model position 1 = " << h_modelPosition_Reread1.x << "," << h_modelPosition_Reread1.y << "," << h_modelPosition_Reread1.z << std::endl;
                    std::cout << "   model position 2 = " << h_modelPosition_Reread2.x << "," << h_modelPosition_Reread2.y << "," << h_modelPosition_Reread2.z << std::endl;
#endif

                    int numIntersecting = 0;
#if 1
                    ObbTreeGPU_BVH_Traverse_Streamed(&obbTree1, &obbTree2,
                                            modelTr1, modelTr2,
                                            _streamedWorkerUnits[k % _numStreamedWorkerUnits.getValue()],
                                            m_alarmDistance, m_contactDistance,
                                            numIntersecting, k);
#endif
                    intersectingTriPairCount[k] = numIntersecting;
                }
            }
#ifdef OBBTREEGPU_COLLISION_DETECTION_END_NARROW_PHASE_DEBUG
            std::cout << "==> intersecting tri-pairs (" << intersectingTriPairCount.size() << " slots): ";

            for (unsigned int m = 0; m < intersectingTriPairCount.size(); m++)
            {
                std::cout << m << " = " << intersectingTriPairCount[m] << ";";
            }
            std::cout << std::endl;
#endif
            /// TODO AB HIER UNTER #pragma omp verschieben...
            for (unsigned int m = 0; m < intersectingTriPairCount.size(); m++)
            {
                std::cout << "CHECK TRIANGLE INTERSECTION: " << intersectingTriPairCount.size() << " pair-wise intersection tests." << std::endl;
                {
                    unsigned int triPairCheckIndex = (i * _numStreamedWorkerUnits.getValue()) + m;
                    std::cout << " iteration = " << i << ", _numStreamedWorkerUnits = " << _numStreamedWorkerUnits.getValue() << ", intersectingTriPairCount index = " << m << std::endl;
                    std::cout << "  triPairCheckIndex = " << triPairCheckIndex << ", _narrowPhasePairs.size() = " << _narrowPhasePairs.size() << std::endl;

                    if (intersectingTriPairCount[m] > 0 && triPairCheckIndex < _narrowPhasePairs.size())
                    {
                        std::pair<OBBModelContainer,OBBModelContainer>& triCheckPair = _narrowPhasePairs.at(triPairCheckIndex);
                        OBBContainer& obbTree1 = triCheckPair.first._obbContainer;
                        OBBContainer& obbTree2 = triCheckPair.second._obbContainer;

                        ObbTreeGPUCollisionModel<Vec3Types>* obbModel1 = triCheckPair.first._obbCollisionModel;
                        ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = triCheckPair.second._obbCollisionModel;

                        std::cout << " - check triangle intersection for " << obbModel1->getName() << " -- " << obbModel2->getName() << std::endl;

                        int potentialResults = intersectingTriPairCount[m] * CollisionTestElementsSize;

                        std::cout << "   potentially intersecting tri-pairs = " << intersectingTriPairCount[m] << "; potential contact points from intersecting triangles = " << potentialResults << std::endl;

                        std::multimap<unsigned int, unsigned int> bestDivSlots;

                        unsigned int curBinSize = _streamedWorkerResultMinSize.getValue();

                        int bestDivSlot = _numStreamedWorkerResultBins.getValue();
                        int modSize = -1;
                        int bestSlotPosition = -1;
                        for (unsigned int l = 0; l < _numStreamedWorkerResultBins.getValue(); l++)
                        {
                            unsigned int sizeDivBinK = potentialResults / curBinSize;
                            unsigned int sizeModBinK = potentialResults % curBinSize;

                            std::cout << "    bin fitting: DivBin_" << l << " = " << sizeDivBinK << ", ModBin_" << l << " = " << sizeModBinK;
                            if (_streamedWorkerResults[l].size() > 0)
                            {
                                std::cout << "    required bins for size " << l << " = " << _streamedWorkerResults[l][0]->_maxResults << ": " << sizeDivBinK << " + " << (sizeModBinK == 0 ? "0" : "1");
                                if (sizeDivBinK > 0 && sizeDivBinK < bestDivSlot)
                                {
                                    bestDivSlot = sizeDivBinK;
                                    bestSlotPosition = l;
                                    modSize = sizeModBinK;
                                }

                                if (sizeModBinK == 0)
                                    modSize = sizeModBinK;

                                bestDivSlots.insert(std::make_pair(l, sizeDivBinK));
                            }
                            std::cout << std::endl;

                            curBinSize *= 2;
                        }

                        if (bestSlotPosition == -1)
                        {
                            bestSlotPosition = 0;
                            bestDivSlot = 1;
                        }
                        std::cout << "    best slot = " << bestSlotPosition << ", bins required = " << bestDivSlot << std::endl;

                        std::cout << "    alternatives: " << bestDivSlots.size() << std::endl;
                        for (std::multimap<unsigned int, unsigned int>::const_iterator it = bestDivSlots.begin(); it != bestDivSlots.end(); it++)
                        {
                            std::cout << "     * " << it->first << ": " << it->second << " result bins" << std::endl;
                        }

                        curBinSize = _streamedWorkerResultMinSize.getValue();
                        int bestModSize = -1;
                        int bestModSlotPosition = -1;
                        for (unsigned int l = 0; l < _numStreamedWorkerResultBins.getValue(); l++)
                        {
                            if (modSize <= curBinSize)
                            {
                                bestModSize = curBinSize;
                                bestModSlotPosition = l;
                            }

                            curBinSize *= 2;
                        }
                        std::cout << "    mod size = " << modSize << ", bestModSize = " << bestModSize << " at bin position = " << bestModSlotPosition << std::endl;

                        if (bestSlotPosition >= 0)
                        {
                            std::vector<gProximityWorkerResult*> freeResultBins;

                            for (unsigned int l = 0; l < _streamedWorkerResults[bestSlotPosition].size(); l++)
                            {
                                if (!_streamedWorkerResults[bestSlotPosition][l]->_blocked)
                                {
                                    _streamedWorkerResults[bestSlotPosition][l]->_blocked = true;
                                    freeResultBins.push_back(_streamedWorkerResults[bestSlotPosition][l]);

                                    if (freeResultBins.size() >= bestDivSlot)
                                        break;
                                }
                            }

                            if (freeResultBins.size() > 0 && freeResultBins.size() == bestDivSlot)
                            {
                                std::vector<std::pair<unsigned int, unsigned int> > freeResultBinSizes;
                                std::vector<unsigned int> freeResultBinStartIndices;
                                unsigned int curEnd = 0;

                                if (freeResultBins.size() > 1)
                                {
                                    for (unsigned int l = 0; l < freeResultBins.size(); l++)
                                    {
                                        freeResultBinSizes.push_back(std::make_pair(0, freeResultBins[l]->_maxResults));
                                        freeResultBinStartIndices.push_back(curEnd);
                                        curEnd += freeResultBins[l]->_maxResults;
                                        /*if (l == 0)
                                        {
                                            freeResultBinSizes.push_back(std::make_pair(0, freeResultBins[l]->_maxResults));
                                        }
                                        else
                                        {
                                            freeResultBinSizes.push_back(std::make_pair(curEnd, curEnd + freeResultBins[l]->_maxResults));
                                        }
                                        ;*/
                                    }
                                }
                                else if (freeResultBins.size() == 1)
                                {
                                    curEnd = freeResultBins[0]->_maxResults;
                                    freeResultBinSizes.push_back(std::make_pair(0, freeResultBins[0]->_maxResults));
                                    freeResultBinStartIndices.push_back(0);
                                }

                                std::cout << "    found " << freeResultBins.size() << " of " << _streamedWorkerResults[bestSlotPosition].size() << " free result bins to do tri-tri tests." << std::endl;

                                bool modSlotAppended = false;
                                if (bestModSlotPosition != -1 && bestModSize != -1)
                                {
                                    std::cout << "     Appending 1 mod result bin from slot " << bestModSize << std::endl;
                                    for (unsigned int l = 0; l < _streamedWorkerResults[bestModSlotPosition].size(); l++)
                                    {
                                        if (!_streamedWorkerResults[bestModSlotPosition][l]->_blocked)
                                        {
                                            _streamedWorkerResults[bestModSlotPosition][l]->_blocked = true;
                                            freeResultBins.push_back(_streamedWorkerResults[bestModSlotPosition][l]);
                                            modSlotAppended = true;
                                            freeResultBinSizes.push_back(std::make_pair(0, modSize));
                                            freeResultBinStartIndices.push_back(curEnd);
                                            break;
                                        }
                                    }
                                }

                                std::cout<< "    result bin ranges: " << freeResultBinSizes.size() << " intervals." << std::endl;
                                for (unsigned int l = 0; l < freeResultBinSizes.size(); l++)
                                {
                                    std::cout << "     * result bin " << l << ": starting at " << freeResultBinStartIndices[l] << ", range = " << freeResultBinSizes[l].first << " - " << freeResultBinSizes[l].second << std::endl;
                                }

                                // CALL block-wise GPU tri-tri test from here!
                                /// TODO: SCHLEIFEN-AUFRUF checken!!! Nur 1 Iteration wird ausgefuehrt!!!
                                int nIntersectingTrianglePairs = 0;
#if 1
                                ObbTreeGPU_TriangleIntersection_Streams(&obbTree1, &obbTree2,
                                                                        _streamedWorkerUnits[m_numOBBTreePairsTested % _numStreamedWorkerUnits.getValue()],
                                                                        freeResultBins,
                                                                        freeResultBinSizes,
                                                                        freeResultBinStartIndices,
                                                                        _triTestStreams[m],
                                                                        modSlotAppended,
                                                                        m_alarmDistance, m_contactDistance, nIntersectingTrianglePairs);
#endif
                                std::cout << "=== Results after tri-tri tests for " << obbModel1->getName() << " -- " << obbModel2->getName() << " ===" << std::endl;
                                unsigned int totalResults = 0;
                                for (unsigned int l = 0; l < freeResultBins.size(); l++)
                                {
                                    totalResults += freeResultBins[l]->_numResults;
                                    std::cout << " * results in bin " << l << ": " << freeResultBins[l]->_numResults << std::endl;
                                }
                                std::cout << " total results = " << totalResults << std::endl;

                                if (totalResults > 0)
                                {
                                    sofa::core::collision::DetectionOutputVector*& outputs = getDetectionOutputs(obbModel1, obbModel2);
                                    sofa::core::collision::TDetectionOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >* discreteOutputs =
                                    m_intersection->getOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2, outputs);

                                    if (discreteOutputs == NULL)
                                    {

                                        discreteOutputs = m_intersection->createOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2);
                                        if (outputs == NULL)
                                        {
                                            outputs = dynamic_cast<sofa::core::collision::DetectionOutputVector*>(discreteOutputs);
                                        }
                                    }

                                    if (outputs && discreteOutputs)
                                    {
                                        const double maxContactDist = m_alarmDistance + (m_alarmDistance - m_contactDistance);
                                        const double maxContactDist2 = maxContactDist * maxContactDist;

                                        for (unsigned int l = 0; l < freeResultBins.size(); l++)
                                        {
                                            gProximityWorkerResult* workerResultUnit = freeResultBins[l];
                                            for (int k = 0; k < workerResultUnit->_numResults; k++)
                                            {

                                                const float3& normalVec = workerResultUnit->d_ptr->h_normal.operator [](k);
                                                Vector3 contactNormal(normalVec.x, normalVec.y, normalVec.z);
                                                const double& contactDistance = workerResultUnit->d_ptr->h_distance.operator [](k);

                                                if (contactNormal.norm() >= 1e-06)
                                                {
                                                    if (contactNormal.norm2() <= maxContactDist2 &&
                                                        std::fabs(contactDistance - m_contactDistance) < m_contactDistance)
                                                    {
                                                        discreteOutputs->resize(discreteOutputs->size()+1);
                                                        sofa::core::collision::DetectionOutput *detection = &*(discreteOutputs->end()-1);

                                                        const int& contactId = workerResultUnit->d_ptr->h_contactId.operator [](k);
                                                        detection->id = contactId;

                                                        const float3& point0 = workerResultUnit->d_ptr->h_point0.operator [](k);
                                                        const float3& point1 = workerResultUnit->d_ptr->h_point1.operator [](k);

                                                        detection->point[0] = Vector3(point0.x, point0.y, point0.z);
                                                        detection->point[1] = Vector3(point1.x, point1.y, point1.z);

                                                        detection->normal = contactNormal;

                                                        // Minus contact distance: Testing...
                                                        detection->value = detection->normal.norm();
                                                        detection->normal /= detection->value;

                                                        detection->value -= m_contactDistance;

                                                        const gProximityContactType& contactType = workerResultUnit->d_ptr->h_gProximityContactType.operator [](k);
                                                        detection->contactType = (sofa::core::collision::DetectionOutputContactType) contactType;

                                                        const int4& contactElems = workerResultUnit->d_ptr->h_elems.operator [](k);
                                                        if (contactType == COLLISION_LINE_LINE)
                                                        {
                                                            detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.w * 3 + contactElems.y); // << CollisionElementIterator

                                                            detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.x * 3 + contactElems.z); // << CollisionElementIterator

                                                            detection->elemFeatures.first = contactElems.y;
                                                            detection->elemFeatures.second = contactElems.z;
                                                        }
                                                        else if (contactType == COLLISION_VERTEX_FACE)
                                                        {
                                                            if (contactElems.z == -1)
                                                            {
                                                                detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.x * 3); // << CollisionElementIterator
                                                                detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.w * 3 + contactElems.y); // << CollisionElementIterator
                                                                detection->elemFeatures.first = contactElems.y;
                                                            }
                                                            else if (contactElems.y == -1)
                                                            {
                                                                detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.x * 3); // << CollisionElementIterator
                                                                detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.w * 3 + contactElems.z); // << CollisionElementIterator
                                                                detection->elemFeatures.second = contactElems.z;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            std::sort(discreteOutputs->begin(), discreteOutputs->end(), contactTypeCompare);

                                            std::pair< core::CollisionModel*, core::CollisionModel* > cm_pair = std::make_pair(obbModel1, obbModel2);

                                            DetectionOutputMap::iterator it = getDetectionOutputs().find(cm_pair);

                                            std::cout << "=== Contact points count for " << obbModel1->getName() << " -- " << obbModel2->getName() << ": " << discreteOutputs->size() << " ===" << std::endl;

                                            if (it == getDetectionOutputs().end())
                                            {
                                                getDetectionOutputs().insert(std::make_pair(cm_pair, outputs));
                                            }
                                            else
                                            {
                                                getDetectionOutputs()[cm_pair] = outputs;
                                            }
                                        }
                                    }
                                }

                                for (unsigned int l = 0; l < freeResultBins.size(); l++)
                                {
                                    freeResultBins[l]->_blocked = false;
                                }
                            }
                            else
                            {
                                for (unsigned int l = 0; l < freeResultBins.size(); l++)
                                {
                                    freeResultBins[l]->_blocked = false;
                                }

                                std::cout << "    WARNING: Insufficient number of result bins available for GPU-based tri-tri tests; falling back to CPU!" << std::endl;
                            }
                        }
                        else
                        {
                            std::cout << "    ERROR: NO RESULT BINS available for GPU-based tri-tri tests; falling back to CPU!" << std::endl;
                        }
                    }
                }
            }
        }
    }

    if (!_useDynamicWorkerScheme.getValue())
    {
        for (unsigned int k = 0; k < _narrowPhasePairs.size(); k++)
        {
            OBBContainer& obbTree1 = _narrowPhasePairs[k].first._obbContainer;
            OBBContainer& obbTree2 = _narrowPhasePairs[k].second._obbContainer;
            ObbTreeGPUCollisionModel<Vec3Types>* obbModel1 = _narrowPhasePairs[k].first._obbCollisionModel;
            ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = _narrowPhasePairs[k].second._obbCollisionModel;

            std::cout << "  - check: " << obbModel1->getName() << " - " << obbModel2->getName() << std::endl;
            {
                if (m_workerUnitOccupied[m_numOBBTreePairsTested % 4] == false)
                {
                    m_workerUnitOccupied[m_numOBBTreePairsTested % 4] = true;

                    int nIntersectingTriPairs = 0;
                    ObbTreeGPU_BVH_Traverse(&obbTree1, &obbTree2,
                                            m_gProximityWorkerUnits[m_numOBBTreePairsTested % 4],
                                            m_alarmDistance, m_contactDistance, nIntersectingTriPairs);

                    if (nIntersectingTriPairs > 0)
                    {
                        unsigned int maxPossibleResults = (obbTree1.nTris * obbTree2.nTris * CollisionTestElementsSize);
                        int potentialResults = nIntersectingTriPairs * CollisionTestElementsSize;

                        std::cout << "    potentially intersecting tri-pairs = " << nIntersectingTriPairs << "; potential contact points from intersecting triangles = " << potentialResults <<  "; max. possible contact results for this OBB pair = " << maxPossibleResults << " (" << obbTree1.nTris << " * " << obbTree2.nTris << " * " << CollisionTestElementsSize << ")" << std::endl;

                        int sizeDivBin1 = potentialResults / m_resultBinSize1;
                        int sizeDivBin2 = potentialResults / m_resultBinSize2;
                        int sizeDivBin3 = potentialResults / m_resultBinSize3;

                        int sizeModBin1 = potentialResults % m_resultBinSize1;
                        int sizeModBin2 = potentialResults % m_resultBinSize2;
                        int sizeModBin3 = potentialResults % m_resultBinSize3;

                        std::cout << "    bin fitting: DivBin1 = " << sizeDivBin1 << ", DivBin2 = " << sizeDivBin2 << ", DivBin3 = " << sizeDivBin3 << std::endl;
                        std::cout << "              ModBin1 = " << sizeModBin1 << ", ModBin2 = " << sizeModBin2 << ", ModBin3 = " << sizeModBin3 << std::endl;

                        std::cout << "    required bins for size1 = " << m_resultBinSize1 << ": " << sizeDivBin1 << " + " << (sizeModBin1 == 0 ? "0" : "1") << std::endl;
                        std::cout << "    required bins for size2 = " << m_resultBinSize2 << ": " << sizeDivBin2 << " + " << (sizeModBin2 == 0 ? "0" : "1") << std::endl;
                        std::cout << "    required bins for size3 = " << m_resultBinSize3 << ": " << sizeDivBin3 << " + " << (sizeModBin3 == 0 ? "0" : "1") << std::endl;

                        gProximityWorkerResult* workerResultUnit = NULL;
                        if (potentialResults < m_resultBinSize1)
                        {
                            workerResultUnit = m_gProximityWorkerResults_64[m_numOBBTreePairsTested % 4];
                            m_workerResultOccupied_64[m_numOBBTreePairsTested % 4] = true;
                            std::cout << "    use result bin 1, up to " << m_resultBinSize1 << " max. contacts." << std::endl;
                        }
                        else if (potentialResults >= m_resultBinSize1 && potentialResults < m_resultBinSize2)
                        {
                            workerResultUnit = m_gProximityWorkerResults_128[m_numOBBTreePairsTested % 4];
                            m_workerResultOccupied_128[m_numOBBTreePairsTested % 4] = true;
                            std::cout << "    use result bin 2, up to " << m_resultBinSize2 << " max. contacts." << std::endl;
                        }
                        else if (potentialResults > m_resultBinSize2 && potentialResults < m_resultBinSize3)
                        {
                            workerResultUnit = m_gProximityWorkerResults_256[m_numOBBTreePairsTested % 4];
                            m_workerResultOccupied_256[m_numOBBTreePairsTested % 4] = true;
                            std::cout << "    use result bin 3, up to " << m_resultBinSize3 << " max. contacts." << std::endl;
                        }
                        else
                        {
                            std::cout << "    TOO BIG TO FIT in bins: " << potentialResults << std::endl;
                        }

                        if (workerResultUnit != NULL)
                        {
                            int nIntersectingTriangles = 0;
                            ObbTreeGPU_TriangleIntersection(&obbTree1, &obbTree2,
                                                            m_gProximityWorkerUnits[m_numOBBTreePairsTested % 4],
                                                            workerResultUnit,
                                                            m_alarmDistance, m_contactDistance, nIntersectingTriangles);

                            if (workerResultUnit->_numResults > 0)
                            {

                                std::cout << "   Results from triangle intersection call = " << workerResultUnit->_numResults << std::endl;

                                sofa::core::collision::DetectionOutputVector*& outputs = getDetectionOutputs(obbModel1, obbModel2);
                                sofa::core::collision::TDetectionOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >* discreteOutputs =
                                m_intersection->getOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2, outputs);

                                if (discreteOutputs == NULL)
                                {

                                    discreteOutputs = m_intersection->createOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2);
                                    if (outputs == NULL)
                                    {
                                        outputs = dynamic_cast<sofa::core::collision::DetectionOutputVector*>(discreteOutputs);
                                    }
                                }

                                if (outputs && discreteOutputs)
                                {
                                    const double maxContactDist = m_alarmDistance + (m_alarmDistance - m_contactDistance);
                                    const double maxContactDist2 = maxContactDist * maxContactDist;

                                    for (int k = 0; k < workerResultUnit->_numResults; k++)
                                    {

                                        /*std::cout << " * id = " << workerResultUnit->h_contactId[k] <<
                                                     ", elems = " << workerResultUnit->h_elems[k].w << "/" << workerResultUnit->h_elems[k].x << "/" << workerResultUnit->h_elems[k].y << "/" << workerResultUnit->h_elems[k].z <<
                                                     ", distance " << workerResultUnit->h_distance[k] <<
                                                     ", point0 = " << workerResultUnit->h_point0[k].x << "," << workerResultUnit->h_point0[k].y << "," << workerResultUnit->h_point0[k].z << "," <<
                                                     ", point1 = " << workerResultUnit->h_point1[k].x << "," << workerResultUnit->h_point1[k].y << "," << workerResultUnit->h_point1[k].z << "," <<
                                                     ", normal = " << workerResultUnit->h_normal[k].x << "," << workerResultUnit->h_normal[k].y << "," << workerResultUnit->h_normal[k].z << "," <<
                                                     ", type = " << workerResultUnit->h_gProximityContactType[k]
                                                     << std::endl;*/

                                        const float3& normalVec = workerResultUnit->d_ptr->h_normal.operator [](k);
                                        Vector3 contactNormal(normalVec.x, normalVec.y, normalVec.z);
                                        const double& contactDistance = workerResultUnit->d_ptr->h_distance.operator [](k);

                                        if (contactNormal.norm() >= 1e-06)
                                        {
                                            if (contactNormal.norm2() <= maxContactDist2 &&
                                                std::fabs(contactDistance - m_contactDistance) < m_contactDistance)
                                            {
                                                discreteOutputs->resize(discreteOutputs->size()+1);
                                                sofa::core::collision::DetectionOutput *detection = &*(discreteOutputs->end()-1);

                                                const int& contactId = workerResultUnit->d_ptr->h_contactId.operator [](k);
                                                detection->id = contactId;

                                                const float3& point0 = workerResultUnit->d_ptr->h_point0.operator [](k);
                                                const float3& point1 = workerResultUnit->d_ptr->h_point1.operator [](k);

                                                detection->point[0] = Vector3(point0.x, point0.y, point0.z);
                                                detection->point[1] = Vector3(point1.x, point1.y, point1.z);

                                                detection->normal = contactNormal;

                                                // Minus contact distance: Testing...
                                                detection->value = detection->normal.norm();
                                                detection->normal /= detection->value;

                                                detection->value -= m_contactDistance;

                                                const gProximityContactType& contactType = workerResultUnit->d_ptr->h_gProximityContactType.operator [](k);
                                                detection->contactType = (sofa::core::collision::DetectionOutputContactType) contactType;

                                                const int4& contactElems = workerResultUnit->d_ptr->h_elems.operator [](k);
                                                if (contactType == COLLISION_LINE_LINE)
                                                {
                                                    detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.w * 3 + contactElems.y); // << CollisionElementIterator

                                                    detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.x * 3 + contactElems.z); // << CollisionElementIterator

                                                    detection->elemFeatures.first = contactElems.y;
                                                    detection->elemFeatures.second = contactElems.z;
                                                }
                                                else if (contactType == COLLISION_VERTEX_FACE)
                                                {
                                                    if (contactElems.z == -1)
                                                    {
                                                        detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.x * 3); // << CollisionElementIterator
                                                        detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.w * 3 + contactElems.y); // << CollisionElementIterator
                                                        detection->elemFeatures.first = contactElems.y;
                                                    }
                                                    else if (contactElems.y == -1)
                                                    {
                                                        detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, contactElems.x * 3); // << CollisionElementIterator
                                                        detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, contactElems.w * 3 + contactElems.z); // << CollisionElementIterator
                                                        detection->elemFeatures.second = contactElems.z;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    std::sort(discreteOutputs->begin(), discreteOutputs->end(), contactTypeCompare);

                                    std::pair< core::CollisionModel*, core::CollisionModel* > cm_pair = std::make_pair(obbModel1, obbModel2);

                                    DetectionOutputMap::iterator it = getDetectionOutputs().find(cm_pair);

                                    std::cout << "   Contact points count = " << discreteOutputs->size() << std::endl;

                                    if (it == getDetectionOutputs().end())
                                    {
                                        getDetectionOutputs().insert(std::make_pair(cm_pair, outputs));
                                    }
                                    else
                                    {
                                        getDetectionOutputs()[cm_pair] = outputs;
                                    }
                                }
                            }
                        }

                        if (potentialResults < m_resultBinSize1)
                        {
                            m_workerResultOccupied_64[m_numOBBTreePairsTested % 4] = false;
                        }
                        else if (potentialResults >= m_resultBinSize1 && potentialResults < m_resultBinSize2)
                        {
                            m_workerResultOccupied_128[m_numOBBTreePairsTested % 4] = false;
                        }
                        else if (potentialResults > m_resultBinSize2 && potentialResults < m_resultBinSize3)
                        {
                            m_workerResultOccupied_256[m_numOBBTreePairsTested % 4] = false;
                        }
                    }

                    m_workerUnitOccupied[m_numOBBTreePairsTested % 4] = false;
                }
            }
            m_numOBBTreePairsTested++;
        }
    }
}


//#define OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
void ObbTreeGPUCollisionDetection::addCollisionModels(const sofa::helper::vector<core::CollisionModel *> v)
{
    if (!this->f_printLog.getValue())
        this->f_printLog.setValue(true);

#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
    sout << "ObbTreeGPUCollisionDetection::addCollisionModels(): " << v.size() << " models." << sendl;
#endif
    for (sofa::helper::vector<core::CollisionModel *>::const_iterator it = v.begin(); it<v.end(); it++)
    {
        bool obbModelFound = false, pqpModelFound = false;
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
        sout << " * Add model " << (*it)->getName() << " of type " << (*it)->getTypeName() << sendl;
#endif
        core::CollisionModel* cmc = (*it);
        do
        {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
            sout << "   examine " << cmc->getName() << ", type " << cmc->getTypeName() << " if it's a ObbTreeGPUCollisionModel" << sendl;
#endif
            ObbTreeGPUCollisionModel<Vec3Types>* obbModel = dynamic_cast<ObbTreeGPUCollisionModel<Vec3Types>*>(cmc);
            if (obbModel)
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
                sout << "    it IS." << sendl;
#endif
                addCollisionModel(cmc);
                obbModelFound = true;
                break;
            }
            else
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
                sout << "    it IS NOT." << sendl;
#endif
            }
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
            sout << "   examine " << cmc->getName() << ", type " << cmc->getTypeName() << " if it's a ObbTreeCPUCollisionModel" << sendl;
#endif
            ObbTreeCPUCollisionModel<Vec3Types>* pqpModel = dynamic_cast<ObbTreeCPUCollisionModel<Vec3Types>*>(cmc);
            if (pqpModel)
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
                sout << "    it IS." << sendl;
#endif
                addCollisionModel(cmc);
                pqpModelFound = true;
                break;
            }
            else
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
                sout << "    it IS NOT." << sendl;
#endif
            }
            cmc = cmc->getNext();
        } while (cmc != NULL);

        if (!obbModelFound && !pqpModelFound)
        {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODELS
            sout << "No ObbTreeGPUCollisionModel found in hierarchy starting at " << (*it)->getName() << ", falling back to BruteForceDetection" << sendl;
#endif
            BruteForceDetection::addCollisionModel((*it));
        }
    }
}

#define OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
void ObbTreeGPUCollisionDetection::addCollisionModel(core::CollisionModel *cm)
{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
	std::cout << "ObbTreeGPUCollisionDetection::addCollisionModel(" << cm->getName() << "), type = " << cm->getTypeName() << std::endl;
#endif

    if (!this->f_printLog.getValue())
        this->f_printLog.setValue(true);

    if (!cm)
        return;


#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
    sout << "ObbTreeGPUCollisionDetection::addCollisionModel(" << cm->getName() << "), type = " << cm->getTypeName() << sendl;
#endif

    ObbTreeGPUCollisionModel<Vec3Types>* obbModel = dynamic_cast<ObbTreeGPUCollisionModel<Vec3Types>*>(cm);

    ObbTreeCPUCollisionModel<Vec3Types>* pqpModel = dynamic_cast<ObbTreeCPUCollisionModel<Vec3Types>*>(cm);

    if (obbModel)
    {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
        sout << "  obbModel = " << obbModel->getName() << " of type " << obbModel->getTypeName() << sendl;
#endif
        bool doGPUObbTest = true;
        if (cm->isSimulated() && cm->getLast()->canCollideWith(cm->getLast()))
        {
            // self collision

#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
			std::cout << " Test for self-collision ability in broad-phase: " << cm->getLast()->getName() << std::endl;
#endif
            bool swapModels = false;
            core::collision::ElementIntersector* intersector = intersectionMethod->findIntersector(cm, cm, swapModels);
            if (intersector != NULL)
            {
                if (intersector->canIntersect(cm->begin(), cm->begin()))
				{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
					std::cout << " Self-collision capable: " << cm->getLast()->getName() << std::endl;
#endif
                    cmPairs.push_back(std::make_pair(cm, cm));
                }
            }
        }
        for (sofa::helper::vector<core::CollisionModel*>::iterator it = collisionModels.begin(); it != collisionModels.end(); ++it)
        {
            core::CollisionModel* cm2 = *it;

            if (!cm->isSimulated() && !cm2->isSimulated())
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
				std::cout << " simulated cm = " << cm->getName() << ": " << cm->isSimulated() << ", cm2 =  " << cm2->getName() << ": " << cm2->isSimulated() << std::endl;
#endif
                continue;
            }

            // bad idea for sofa standard models. If this define is set, Bolzen/Bohrung scenario detects a contact within one mesh and crashes after the first 'real' contacts are detected.
            if (!keepCollisionBetween(cm->getLast(), cm2->getLast()))
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
				std::cout << " collisions between cm = " << cm->getLast()->getName() << " and " << cm2->getLast()->getName() << " not kept!" << sendl;
#endif
                continue;
            }

            bool swapModels = false;
            core::collision::ElementIntersector* intersector = intersectionMethod->findIntersector(cm, cm2, swapModels);
            if (intersector == NULL)
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
				std::cout << " no suitable intersector between cm = " << cm->getName() << " and " << cm2->getName() << " found!" << std::endl;
#endif
                continue;
            }
            core::CollisionModel* cm1 = (swapModels?cm2:cm);
            cm2 = (swapModels?cm:cm2);

            // Here we assume a single root element is present in both models

#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
			std::cout << " Intersector used for intersectability query: " << intersector->name() << std::endl;
#endif
            if (intersector->canIntersect(cm1->begin(), cm2->begin()))
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
				std::cout << "Broad phase " << cm1->getLast()->getName() << " - " << cm2->getLast()->getName() << std::endl;
#endif
                cmPairs.push_back(std::make_pair(cm1, cm2));
            }
            else
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
				std::cout << " cm1 = " << cm->getName() << " and cm2 = " << cm2->getName() << " can't intersect!" << std::endl;
#endif
                doGPUObbTest = false;
            }
        }

        collisionModels.push_back(cm);

        if (doGPUObbTest)
        {
            std::map<std::string, ObbTreeGPUCollisionModel<Vec3Types>*>::const_iterator mit = m_obbModels.find(obbModel->getName());

            if (mit == m_obbModels.end())
            {
    #ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                sout << "   registering OBB model " << obbModel->getName() << sendl;
    #endif
                m_obbModels.insert(std::make_pair(obbModel->getName(), obbModel));
            }

            /*for (std::map<std::string, ObbTreeGPUCollisionModel<Vec3Types>*>::iterator it = m_obbModels.begin(); it != m_obbModels.end(); it++)
            {
                ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = it->second;
    #ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                sout << "   check possible intersection with OBB model " << obbModel2->getName() << sendl;
    #endif
                if (obbModel2->getName() == obbModel->getName())
                {
    #ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                    sout << "     no self-intersection between OBB-Models supported!" << sendl;
    #endif
                    continue;
                }

                if (obbModel->canCollideWith(obbModel2))
                {
    #ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                    sout << "    canCollideWith " << obbModel2->getName() << ": OK." << sendl;
    #endif
                    cmPairs.push_back(std::make_pair(obbModel, obbModel2));
                }
    #ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                else
                {
                    sout << "    canCollideWith " << obbModel2->getName() << ": FAIL." << sendl;
                }
    #endif
            }*/
        }
    }
    else if (pqpModel)
    {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
        sout << "  pqpModel = " << pqpModel->getName() << " of type " << pqpModel->getTypeName() << sendl;
#endif
        std::map<std::string, ObbTreeCPUCollisionModel<Vec3Types>*>::const_iterator mit = m_pqpModels.find(pqpModel->getName());

        if (mit == m_pqpModels.end())
        {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
            sout << "   registering PQP model " << pqpModel->getName() << sendl;
#endif
            m_pqpModels.insert(std::make_pair(pqpModel->getName(), pqpModel));
        }

        for (std::map<std::string, ObbTreeCPUCollisionModel<Vec3Types>*>::iterator it = m_pqpModels.begin(); it != m_pqpModels.end(); it++)
        {
            ObbTreeCPUCollisionModel<Vec3Types>* pqpModel2 = it->second;
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
            sout << "   check possible intersection with PQP model " << pqpModel2->getName() << sendl;
#endif
//            if (!pqpModel2->isSimulated())
//            {
//                sout << "     not simulated, aborting" << sendl;
//                continue;
//            }

            if (pqpModel2->getName() == pqpModel->getName())
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                sout << "     no self-intersection between PQP-Models supported!" << sendl;
#endif
                continue;
            }

            if (pqpModel->canCollideWith(pqpModel2))
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                sout << "    canCollideWith " << pqpModel2->getName() << ": OK." << sendl;
#endif
                cmPairs.push_back(std::make_pair(pqpModel, pqpModel2));
            }
            else
            {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
                sout << "    canCollideWith " << pqpModel2->getName() << ": FAIL." << sendl;
#endif
            }
        }
    }
    else
    {
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONMODEL
        sout << "Model " << cm->getName() << " is not a ObbTreeGPU model, fallback to BruteForceDetection" << sendl;
#endif
        BruteForceDetection::addCollisionModel(cm);
    }
}

//#define OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
void ObbTreeGPUCollisionDetection::addCollisionPairs(const sofa::helper::vector<std::pair<core::CollisionModel *, core::CollisionModel *> > &v)
{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
    sout << "=== ObbTreeGPUCollisionDetection::addCollisionPairs(): " << v.size() << " possible pairs. ===" << sendl;
    int addedPairs = 0;
#endif
	for (sofa::helper::vector< std::pair<core::CollisionModel*, core::CollisionModel*> >::const_iterator it = v.begin(); it != v.end(); it++)
	{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
		sout << " Add: " << it->first->getName() << " -- " << it->second->getName() << sendl;
#endif

		const std::string& m1Name = it->first->getName();
		const std::string& m2Name = it->second->getName();

		//const helper::vector<std::string>& m1_scm = it->first->getTP_SpecialCollisionModel();
		//const helper::vector<std::string>& m2_scm = it->second->getTP_SpecialCollisionModel();
		const helper::vector<std::string>& m1Blacklist = it->first->getCollisionModelBlacklist();
		const helper::vector<std::string>& m2Blacklist = it->second->getCollisionModelBlacklist();
		const helper::vector<std::string>& m1Whitelist = it->first->getCollisionModelWhitelist();
		const helper::vector<std::string>& m2Whitelist = it->second->getCollisionModelWhitelist();

		bool onCollisionWhitelist = false;
		bool onCollisionBlacklist = false;
		bool whitelistRelevant = ((m1Whitelist.size() > 0) || (m2Whitelist.size() > 0));
		bool blacklistRelevant = ((m1Blacklist.size() > 0) || (m2Blacklist.size() > 0));

		if (whitelistRelevant && blacklistRelevant)
		{
			sout << "WARNING: There exists at least one non-empty whitelist and one non-empty blacklist for the contact " << it->first->getName() << "-" << it->second->getName() << ". The blacklists are ignored." << std::endl;
			blacklistRelevant = false;
		}

		// checks if (at least) one collision model's name appears in the whitelist of the other
		// (but not if both whitelists are empty - in that case, check the blacklists)
		if (whitelistRelevant)
		{
			for (helper::vector<std::string>::const_iterator m1_it = m1Whitelist.begin(); m1_it != m1Whitelist.end(); ++m1_it)
			{
				if (m2Name.compare(*m1_it) == 0)
				{
					//std::cout << m1Name << " has a whitelist entry for " << m2Name << std::endl;
					onCollisionWhitelist = true;
					break;
				}
			}
			for (helper::vector<std::string>::const_iterator m2_it = m2Whitelist.begin(); m2_it != m2Whitelist.end(); ++m2_it)
			{
				if (m1Name.compare(*m2_it) == 0)
				{
					//std::cout << m2Name << " has a whitelist entry for " << m1Name << std::endl;
					onCollisionWhitelist = true;
					break;
				}
			}

		}
		// The blacklists are ignored if the at least one whitelist is not empty
		else
		{			
			// checks if (at least) one collision model's name appears in the blacklist of the other
			// (but not if both blacklists are empty)
			if (blacklistRelevant)
			{
				for (helper::vector<std::string>::const_iterator m1_it = m1Blacklist.begin(); m1_it != m1Blacklist.end(); ++m1_it)
				{
					if (m2Name.compare(*m1_it) == 0)
					{
						//std::cout << m1Name << " has a blacklist entry for " << m2Name << std::endl;
						onCollisionBlacklist = true;
						break;
					}
				}
				for (helper::vector<std::string>::const_iterator m2_it = m2Blacklist.begin(); m2_it != m2Blacklist.end(); ++m2_it)
				{
					if (m1Name.compare(*m2_it) == 0) 
					{
						//std::cout << m2Name << " has a blacklist entry for " << m1Name << std::endl;
						onCollisionBlacklist = true;
						break;
					}
				}
			}

			/*
			if (!onCollisionBlacklist)
			{
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
				addedPairs++;
#endif
				addCollisionPair(*it);
			}
			*/
		}

		if  (  (whitelistRelevant  && onCollisionWhitelist ) 
			|| (blacklistRelevant  && !onCollisionBlacklist)
			|| (!blacklistRelevant && !whitelistRelevant   )
			)
		{
			//std::cout <<  "Adding collisision pair for contact" << it->first->getName() << "-" << it->second->getName() << "." << std::endl;
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
			addedPairs++;
#endif
			addCollisionPair(*it);
		}
    }
#ifdef OBBTREEGPUCOLLISIONDETECTION_DEBUG_ADDCOLLISIONPAIRS
    sout << "=== ObbTreeGPUCollisionDetection::addCollisionPairs(): " << addedPairs << " pairs added. ===" << sendl;
#endif
}

#include "ObbTree.h"

//#define OBBTREE_GPU_DEBUG_TRANSFORMED_VERTICES
//#define OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_TRIANGLES
#define OBBTREE_GPU_COLLISION_DETECTION_DEBUG
void ObbTreeGPUCollisionDetection::addCollisionPair(const std::pair<core::CollisionModel*, core::CollisionModel*> &cmPair)
{
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
    sout << "ObbTreeGPUCollisionDetection::addCollisionPair(" << cmPair.first->getName() << "," << cmPair.second->getName() << ")" << sendl;
    sout << " model types: " << cmPair.first->getTypeName() << " - " << cmPair.second->getTypeName() << sendl;
#endif

    ObbTreeGPUCollisionModel<Vec3Types>* obbModel1 = dynamic_cast<ObbTreeGPUCollisionModel<Vec3Types>*>(cmPair.first);
    ObbTreeGPUCollisionModel<Vec3Types>* obbModel2 = dynamic_cast<ObbTreeGPUCollisionModel<Vec3Types>*>(cmPair.second);

    ObbTreeCPUCollisionModel<Vec3Types>* pqpModel1 = dynamic_cast<ObbTreeCPUCollisionModel<Vec3Types>*>(cmPair.first);
    ObbTreeCPUCollisionModel<Vec3Types>* pqpModel2 = dynamic_cast<ObbTreeCPUCollisionModel<Vec3Types>*>(cmPair.second);

    if (obbModel1 && obbModel2)
    {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
        sout << " check using GPU-based implementation" << sendl;
#endif
        std::pair<std::string, std::string> pairCombo1 = std::make_pair(obbModel1->getName(), obbModel2->getName());
        std::pair<std::string, std::string> pairCombo2 = std::make_pair(obbModel2->getName(), obbModel1->getName());

        bool combo1Found = false;
        bool combo2Found = false;

        bool combo1Used = false;
        bool combo2Used = false;

        for (std::vector<std::pair<std::string, std::string> >::const_iterator it = m_testedModelPairs.begin(); it != m_testedModelPairs.end(); it++)
        {
            if (it->first.compare(pairCombo1.first) == 0 && it->second.compare(pairCombo1.second) == 0)
                combo1Found = true;

            if (it->first.compare(pairCombo2.first) == 0 && it->second.compare(pairCombo2.second) == 0)
                combo2Found = true;
        }

        if (!combo1Found)
        {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " not tested yet: combo1 = " << pairCombo1.first << " -- " << pairCombo1.second << std::endl;
#endif
            m_testedModelPairs.push_back(pairCombo1);
            combo1Used = true;
        }
        else
        {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " already tested: combo1 = " << pairCombo1.first << " -- " << pairCombo1.second << std::endl;
#endif
            return;
        }

        if (!combo2Found)
        {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " not tested yet: combo2 = " << pairCombo2.first << " -- " << pairCombo2.second << std::endl;
#endif
            combo2Used = true;
            m_testedModelPairs.push_back(pairCombo2);
        }
        else
        {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " already tested: combo2 = " << pairCombo2.first << " -- " << pairCombo2.second << std::endl;
#endif
            return;
        }

        std::vector<std::pair<int,int> > allPairs;
        int* allOBBPairs = NULL;

        struct OBBContainer obbTree1;
        struct OBBContainer obbTree2;

        obbTree1.nVerts = obbModel1->numVertices();
        obbTree2.nVerts = obbModel2->numVertices();
        obbTree1.nTris = obbModel1->numTriangles();
        obbTree2.nTris = obbModel2->numTriangles();
        obbTree1.nBVs = obbModel1->numOBBs();
        obbTree2.nBVs = obbModel2->numOBBs();

        obbTree1.obbTree = obbModel1->obbTree_device();
        obbTree2.obbTree = obbModel2->obbTree_device();
        obbTree1.vertexPointer = obbModel1->vertexPointer_device();
        obbTree2.vertexPointer = obbModel2->vertexPointer_device();

        obbTree1.vertexTfPointer = obbModel1->vertexTfPointer_device();
        obbTree2.vertexTfPointer = obbModel2->vertexTfPointer_device();

        obbTree1.triIdxPointer = obbModel1->triIndexPointer_device();
        obbTree2.triIdxPointer = obbModel2->triIndexPointer_device();

        if (_useStreamedCollisionQueries.getValue())
        {
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << "USE STREAMED COLLISION QUERIES" << std::endl;
    #endif

            OBBModelContainer obbContainer1, obbContainer2;
            obbContainer1._obbContainer = obbTree1;
            obbContainer1._obbCollisionModel = obbModel1;
            obbContainer2._obbContainer = obbTree2;
            obbContainer2._obbCollisionModel = obbModel2;

    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " combo1Found = " << combo1Found << ", combo1Used = " << combo1Used << ";" <<
                         " combo2Found = " << combo2Found << ", combo2Used = " << combo2Used << std::endl;
    #endif


            if (combo1Used && combo2Used)
            {
                std::cout << "  push combo1; no combo registered yet = " << obbModel1->getName() << " -- " << obbModel2->getName() << std::endl;
                _narrowPhasePairs.push_back(std::make_pair(obbContainer1, obbContainer2));
            }
            else if (combo1Used && !combo2Used)
            {
                std::cout << "  push combo1 = " << obbModel1->getName() << " -- " << obbModel2->getName() << std::endl;
                _narrowPhasePairs.push_back(std::make_pair(obbContainer1, obbContainer2));
            }
            else if (combo2Used && !combo1Used)
            {
                std::cout << "  push combo2 = " << obbModel2->getName() << " -- " << obbModel1->getName() << std::endl;
                _narrowPhasePairs.push_back(std::make_pair(obbContainer2, obbContainer1));
            }
            else
            {
                std::cout << "  WARNING -- combo1/2 used flags not set, skipping: " << obbModel1->getName() << " -- " << obbModel2->getName() << std::endl;
            }
        }
        else
        {
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << "USE FULL ALLOCATION ON GPU" << std::endl;
    #endif
            Vector3 modelPos1, modelPos2;
            Matrix3 modelOri1, modelOri2;

            modelPos1 = obbModel1->getCachedPosition();
            modelPos2 = obbModel2->getCachedPosition();

            Quaternion modelQuat1 = obbModel1->getCachedOrientation();
            Quaternion modelQuat2 = obbModel2->getCachedOrientation();
            modelQuat1.toMatrix(modelOri1);
            modelQuat2.toMatrix(modelOri2);

    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
            std::cout << " obbModel1 position from MechanicalObject = " << modelPos1 << ", orientation = " << modelOri1 << std::endl;
            std::cout << " obbModel2 position from MechanicalObject = " << modelPos2 << ", orientation = " << modelOri2 << std::endl;
    #endif

            obbTree1.modelTransform.m_T[0] = modelPos1.x(); obbTree1.modelTransform.m_T[1] = modelPos1.y(); obbTree1.modelTransform.m_T[2] = modelPos1.z();
            obbTree2.modelTransform.m_T[0] = modelPos2.x(); obbTree2.modelTransform.m_T[1] = modelPos2.y(); obbTree2.modelTransform.m_T[2] = modelPos2.z();

            for (short k = 0; k < 3; k++)
            {
                for (short l = 0; l < 3; l++)
                {
                    obbTree1.modelTransform.m_R[k][l] = modelOri1(k,l);
                    obbTree2.modelTransform.m_R[k][l] = modelOri2(k,l);
                }
            }

            gProximityDetectionOutput* detectedContacts = NULL;
            int nContacts = 0;
            int nIntersecting = 0;
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_FULL_ALLOCATION_DETECTION
            {

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_RECORD_INTERSECTING_OBBS
                int nIntersectingOBBs = 0;
        #endif
        #ifdef OBBTREE_GPU_DEBUG_TRANSFORMED_VERTICES
                GPUVertex* tfVertices1 = new GPUVertex[obbTree1.nVerts];
                GPUVertex* tfVertices2 = new GPUVertex[obbTree2.nVerts];
        #endif


        #ifdef OBBTREE_GPU_DEBUG_TRANSFORMED_VERTICES
            std::cout << " Non-Streams intersecting = " << nIntersecting << std::endl;
        #endif
        #ifdef SOFA_DUMP_VISITOR_INFO
                std::stringstream visitorId;
                visitorId << "ObbTreeGPU_BVHCollide(" << obbModel1->getName() << " - " << obbModel2->getName() << ")";
                simulation::Visitor::printNode("ObbTreeGPU_BVHCOLLIDE");
                sofa::helper::AdvancedTimer::stepBegin(visitorId.str().c_str());
        #endif

                nIntersecting = 0;
                ObbTreeGPU_BVHCollide(&obbTree1, &obbTree2, allPairs
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_RECORD_INTERSECTING_OBBS
                    , &allOBBPairs, &nIntersectingOBBs
    #endif
    #ifdef OBBTREE_GPU_DEBUG_TRANSFORMED_VERTICES
                    , (void**) &tfVertices1, (void**) &tfVertices2
    #endif
                    , &detectedContacts
                    , &nContacts
                    , m_alarmDistance
                    , m_contactDistance
                    , nIntersecting
                );

                std::cout << " Non-Streams intersecting = " << nIntersecting << std::endl;

        #ifdef SOFA_DUMP_VISITOR_INFO
                simulation::Visitor::printCloseNode("ObbTreeGPU_BVHCOLLIDE");
                sofa::helper::AdvancedTimer::stepEnd(visitorId.str().c_str());
        #endif //OBBTREE_GPU_COLLISION_DETECTION_FULL_ALLOCATION_DETECTION
            }
    #endif

    #ifdef OBBTREE_GPU_COLLISION_DETECTION_FULL_ALLOCATION_DETECTION
            {
        #ifdef OBBTREE_GPU_DEBUG_TRANSFORMED_VERTICES
                std::string collisionPairId(obbModel1->getName() + "::" + obbModel2->getName());
                if (m_transformedVertices.find(collisionPairId) == m_transformedVertices.end())
                {
                    m_transformedVertices.insert(std::make_pair(collisionPairId, std::make_pair(tfVertices1, tfVertices2)));
                }
                else
                {
                    delete[] m_transformedVertices[collisionPairId].first;
                    delete[] m_transformedVertices[collisionPairId].second;

                    m_transformedVertices[collisionPairId] = std::make_pair(tfVertices1, tfVertices2);
                }
        #endif
                if (nIntersecting > 0)
                {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_TRIANGLES
                    std::cout << "Intersecting triangle pairs: " << nIntersecting << " -- ";
        #endif
        #if 0
                    std::vector<std::pair<int, int> > intersectingTriIndices;

                    for (int k = 0; k < nIntersecting; k++)
                    {
                        intersectingTriIndices.push_back(std::make_pair(std::abs(allPairs[k].first),std::abs(allPairs[k].second)));
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_TRIANGLES
                        std::cout << std::abs(allPairs[k].first) << " - ";
                        std::cout << std::abs(allPairs[k].second) << "; ";
        #endif
                    }
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_TRIANGLES
                    std::cout << std::endl;
        #endif
                    m_intersectingTriangles.insert(std::make_pair(collisionPairId, intersectingTriIndices));
        #endif
                    //if (nContacts > 0)
                    {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                        std::cout << "=== Contacts recorded: " << nContacts << " ===" << std::endl;
        #endif

                        sofa::core::collision::DetectionOutputVector*& outputs = getDetectionOutputs(obbModel1, obbModel2);
                        sofa::core::collision::TDetectionOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >* discreteOutputs =
                        m_intersection->getOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2, outputs);

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                        std::cout << " outputs = " << outputs << ", discreteOutputs = " << discreteOutputs << std::endl;
        #endif

                        if (discreteOutputs == NULL)
                        {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                            std::cout << " no discreteOutputs pointer exists yet; creating output vector via m_intersection" << std::endl;
        #endif

                            discreteOutputs = m_intersection->createOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, obbModel2);
                            if (outputs == NULL)
                            {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                std::cout << " dynamic_cast'ing discreteOutputs for registration in DetectionOutputMap" << std::endl;
        #endif

                                outputs = dynamic_cast<sofa::core::collision::DetectionOutputVector*>(discreteOutputs);
                            }
                        }

                        const double maxContactDist = m_alarmDistance + (m_alarmDistance - m_contactDistance);
                        const double maxContactDist2 = maxContactDist * maxContactDist;

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                        std::cout << "=== Contact points generated: " << nContacts << " ===" << std::endl;
        #endif

                        for (int k = 0; k < nContacts; k++)
                        {
                            Vector3 contactNormal(detectedContacts->normal[k].x, detectedContacts->normal[k].y, detectedContacts->normal[k].z);

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                            std::cout << " -> " << k << ": contactNormal = " << contactNormal << ", contactNormal.norm() = " << contactNormal.norm() << "; distance = " << detectedContacts->distance[k] << ", contactDistance = " << m_contactDistance << std::endl;
        #endif

                            if (contactNormal.norm() >= 1e-06)
                            {
                                if (contactNormal.norm2() <= maxContactDist2 &&
                                    std::fabs(detectedContacts->distance[k] - m_contactDistance) < m_contactDistance)
                                {
                                    discreteOutputs->resize(discreteOutputs->size()+1);
                                    sofa::core::collision::DetectionOutput *detection = &*(discreteOutputs->end()-1);

                                    detection->id = detectedContacts->contactId[k];

                                    // Swapped: Testing...: This is legitimate???
                                    /*if (detectedContacts->contactType[k] == COLLISION_LINE_LINE)
                                    {
                                        detection->point[1] = Vector3(detectedContacts->point0[k].x, detectedContacts->point0[k].y, detectedContacts->point0[k].z);
                                        detection->point[0] = Vector3(detectedContacts->point1[k].x, detectedContacts->point1[k].y, detectedContacts->point1[k].z);
                                    }
                                    else if (detectedContacts->contactType[k] == COLLISION_VERTEX_FACE ||
                                             detectedContacts->contactType[k] == COLLISION_LINE_POINT)
                                    {
                                        detection->point[0] = Vector3(detectedContacts->point0[k].x, detectedContacts->point0[k].y, detectedContacts->point0[k].z);
                                        detection->point[1] = Vector3(detectedContacts->point1[k].x, detectedContacts->point1[k].y, detectedContacts->point1[k].z);
                                    }*/

                                    detection->point[0] = Vector3(detectedContacts->point0[k].x, detectedContacts->point0[k].y, detectedContacts->point0[k].z);
                                    detection->point[1] = Vector3(detectedContacts->point1[k].x, detectedContacts->point1[k].y, detectedContacts->point1[k].z);

                                    // Negated: Testing...: THIS WAS A FACEPALM type FAILURE!!!
                                    /*if (detectedContacts->contactType[k] == COLLISION_VERTEX_FACE)
                                        detection->normal = -contactNormal;
                                    else
                                        detection->normal = contactNormal;*/

                                    detection->normal = contactNormal;

                                    // Minus contact distance: Testing...
                                    detection->value = detection->normal.norm();
                                    detection->normal /= detection->value;

                                    detection->value -= m_contactDistance;

                                    detection->contactType = (sofa::core::collision::DetectionOutputContactType) detectedContacts->contactType[k];

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                    std::cout << " * " << k << " data: contact id = " << detection->id << ",";
                                    std::cout << " type = " << detection->contactType << " = ";
                                    if (detection->contactType == sofa::core::collision::CONTACT_LINE_LINE)
                                        std::cout << "LINE_LINE: tri1/edge1 = " << detectedContacts->elems[k].w << "/" << detectedContacts->elems[k].y << " -- tri2/edge2 = " << detectedContacts->elems[k].x << "/" << detectedContacts->elems[k].z;
                                    else if (detection->contactType == sofa::core::collision::CONTACT_FACE_VERTEX)
                                        std::cout << "FACE_VERTEX: tri1 = " << detectedContacts->elems[k].w << ", tri2 = " << detectedContacts->elems[k].x;
                                    else if (detection->contactType == sofa::core::collision::CONTACT_LINE_VERTEX)
                                        std::cout << "LINE_VERTEX: tri1 = " << detectedContacts->elems[k].w << ", tri2 = " << detectedContacts->elems[k].x;

                                    std::cout << "; distance = " << detection->value << "; point0 = " << detection->point[0] << ", point1 = " << detection->point[1] << ", normal = " << detection->normal << std::endl;
        #endif
                                    if (detectedContacts->contactType[k] == COLLISION_LINE_LINE)
                                    {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                        std::cout << "   edge0 index = " << detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y << " (" << detectedContacts->elems[k].w  << " * 3 + " << detectedContacts->elems[k].y << ")" << std::endl;
        #endif
                                        detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y); // << CollisionElementIterator

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                        std::cout << "   edge1 index = " << detectedContacts->elems[k].x * 3 + detectedContacts->elems[k].z << " (" << detectedContacts->elems[k].x  << " * 3 + " << detectedContacts->elems[k].z << ")" << std::endl;
        #endif

                                        detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, detectedContacts->elems[k].x * 3 + detectedContacts->elems[k].z); // << CollisionElementIterator

                                        detection->elemFeatures.first = detectedContacts->elems[k].y;
                                        detection->elemFeatures.second = detectedContacts->elems[k].z;
                                    }
                                    else if (detectedContacts->contactType[k] == COLLISION_VERTEX_FACE)
                                    {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                        std::cout << "   tri0 = " << detectedContacts->elems[k].w << ", tri1 = " << detectedContacts->elems[k].x << ", vertex0 = " << detectedContacts->elems[k].y << ", vertex1 = " << detectedContacts->elems[k].z << std::endl;
        #endif

                                        if (detectedContacts->elems[k].z == -1)
                                        {
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                            std::cout << "   contact with first triangle: elem.first = " << detectedContacts->elems[k].x * 3 << ", elem.second = " << detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y << std::endl;
        #endif

                                            detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, detectedContacts->elems[k].x * 3); // << CollisionElementIterator
                                            detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y); // << CollisionElementIterator
                                            detection->elemFeatures.first = detectedContacts->elems[k].y;
                                        }
                                        else if (detectedContacts->elems[k].y == -1)
                                        {

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                                            std::cout << "   contact with second triangle: elem.first = " << detectedContacts->elems[k].x * 3 << ", elem.second = " << detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y << std::endl;
        #endif

                                            detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, detectedContacts->elems[k].x * 3); // << CollisionElementIterator
                                            detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].z); // << CollisionElementIterator
                                            detection->elemFeatures.second = detectedContacts->elems[k].z;
                                        }
                                    }
                                    else if (detectedContacts->contactType[k] == COLLISION_LINE_POINT)
                                    {
                                        detection->elem.first = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel1, detectedContacts->elems[k].w * 3 + detectedContacts->elems[k].y); // << CollisionElementIterator
                                        detection->elem.second = sofa::core::TCollisionElementIterator<ObbTreeGPUCollisionModel<Vec3Types> >(obbModel2, detectedContacts->elems[k].x * 3 + detectedContacts->elems[k].z); // << CollisionElementIterator
                                        detection->elemFeatures.first = detectedContacts->elems[k].y;
                                        detection->elemFeatures.second = detectedContacts->elems[k].z;
                                    }
                                }
                            }
                        }

                        delete[] detectedContacts->contactId;
                        detectedContacts->contactId = NULL;
                        delete[] detectedContacts->contactType;
                        detectedContacts->contactType = NULL;
                        delete[] detectedContacts->distance;
                        detectedContacts->distance = NULL;
                        delete[] detectedContacts->elems;
                        detectedContacts->elems = NULL;
                        delete[] detectedContacts->normal;
                        detectedContacts->normal = NULL;
                        delete[] detectedContacts->point0;
                        detectedContacts->point0 = NULL;
                        delete[] detectedContacts->point1;
                        detectedContacts->point1 = NULL;
                        delete[] detectedContacts->valid;
                        detectedContacts->valid = NULL;

                        delete detectedContacts;
                        detectedContacts = NULL;

                        std::sort(discreteOutputs->begin(), discreteOutputs->end(), contactTypeCompare);

        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
                        std::cout << "=== after sorting by contact type ===" << std::endl;
                        for (sofa::core::collision::TDetectionOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >::const_iterator it = discreteOutputs->begin(); it != discreteOutputs->end(); it++)
                        {
                            std::cout << " - " << (*it).contactType << ", point0 = " << (*it).point[0] << " -- " << (*it).point[1] << std::endl;
                        }
        #endif
                        std::pair< core::CollisionModel*, core::CollisionModel* > cm_pair = std::make_pair(obbModel1, obbModel2);

                        DetectionOutputMap::iterator it = getDetectionOutputs().find(cm_pair);

                        if (it == getDetectionOutputs().end())
                        {
                            getDetectionOutputs().insert(std::make_pair(cm_pair, outputs));
                        }
                        else
                        {
                            getDetectionOutputs()[cm_pair] = outputs;
                        }
        #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_CONTACT_POINTS
                        std::cout << " after filling contacts vector: " << std::endl;
                        std::cout << getDetectionOutputs()[cm_pair]->size() << " elements created." << std::endl;
                        for (sofa::core::collision::TDetectionOutputVector<ObbTreeGPUCollisionModel<Vec3Types>, ObbTreeGPUCollisionModel<Vec3Types> >::const_iterator it = discreteOutputs->begin(); it != discreteOutputs->end(); it++)
                        {
                            std::cout << " - Elements: " << it->elem.first.getIndex() << " -- " << it->elem.second.getIndex() << "; distance = " << it->value << "; id = " << it->id << std::endl;
                        }
        #endif
                    }
                }
            }
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_RECORD_INTERSECTING_OBBS
            if (nIntersectingOBBs > 0)
            {
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_OBBS
                std::cout << "Intersecting OBB pairs: " << nIntersectingOBBs << " -- ";
    #endif
                std::vector<std::pair<int, int> > intersectingOBBIndices;
                for (int k = 0; k < 2 * nIntersectingOBBs; k++)
                {
                    if (k % 2 != 0)
                    {
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_OBBS
                        std::cout << allOBBPairs[k-1] << "," << allOBBPairs[k] << ";";
    #endif
                        intersectingOBBIndices.push_back(std::make_pair(allOBBPairs[k-1],allOBBPairs[k]));
                    }
                }
                m_intersectingOBBs.insert(std::make_pair(collisionPairId, intersectingOBBIndices));
    #ifdef OBBTREE_GPU_COLLISION_DETECTION_DUMP_INTERSECTING_OBBS
                std::cout << std::endl;
    #endif
            }
            delete[] allOBBPairs;
    #endif

    #endif //OBBTREE_GPU_COLLISION_DETECTION_FULL_ALLOCATION_DETECTION
    }
    }
    else if (pqpModel1 && pqpModel2)
    {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
         std::cout << "Check using CPU-based implementation" << std::endl;
#endif

         CollideResult colResult;
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
         std::cout << "=== TEST tree1 against tree2 ===" << std::endl;
#endif
         pqpModel1->getObbTree().testOverlap(pqpModel2->getObbTree(), colResult);

#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
         std::cout << "=== RESULTS tree1 against tree2 ===" << std::endl;
         std::cout << " OBB tests done: " << colResult.num_bv_tests << "; tri-box tests done: " << colResult.num_tri_box_tests << ", tri-tri tests done: " << colResult.num_tri_tests << std::endl;

         std::cout << " overlapping obb pairs: " << colResult.num_obb_pairs << std::endl;
         for (int k = 0; k < colResult.NumOBBPairs(); k++)
         {
             std::cout << " - " << colResult.obb_pairs[k].id1 << " -- " << colResult.obb_pairs[k].id2 << std::endl;
         }

         std::cout << " overlapping tri pairs: " << colResult.num_pairs << std::endl;
         for (int k = 0; k < colResult.NumPairs(); k++)
         {
             std::cout << " - " << colResult.pairs[k].id1 << " -- " << colResult.pairs[k].id2 << std::endl;
         }
#endif

         std::string collisionPairId(pqpModel1->getName() + "::" + pqpModel2->getName());

         if (colResult.NumPairs() > 0)
         {
             std::vector<std::pair<int, int> > intersectingTriIndices;
             for (int k = 0; k < colResult.NumPairs(); k++)
             {
                 intersectingTriIndices.push_back(std::make_pair(std::abs(colResult.pairs[k].id1), std::abs(colResult.pairs[k].id2)));
             }
             m_intersectingTriangles.insert(std::make_pair(collisionPairId, intersectingTriIndices));
         }

         if (colResult.NumOBBPairs() > 0)
         {
             std::vector<std::pair<int, int> > intersectingOBBIndices;
             for (int k = 0; k < colResult.NumOBBPairs(); k++)
             {
                 intersectingOBBIndices.push_back(std::make_pair(colResult.obb_pairs[k].id1, colResult.obb_pairs[k].id2));
             }
             m_intersectingOBBs.insert(std::make_pair(collisionPairId, intersectingOBBIndices));
         }

         if (colResult.NumOBBPairs() > 0)
         {
             std::vector<int> emphasizeOBBs1, emphasizeOBBs2;
             for (int k = 0; k < colResult.NumOBBPairs(); k++)
             {
                 emphasizeOBBs1.push_back(colResult.obb_pairs[k].id1);
                 emphasizeOBBs2.push_back(colResult.obb_pairs[k].id2);
             }

             pqpModel1->setEmphasizedIndices(emphasizeOBBs1);
             pqpModel2->setEmphasizedIndices(emphasizeOBBs2);
         }
    }
    else
    {
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG
        sout << " check using default BruteForceDetection implementation" << sendl;
#endif
        BruteForceDetection::addCollisionPair(cmPair);
    }
}

#include "BVHDrawHelpers.h"

//#define OBBTREE_GPU_COLLISION_DETECTION_DEBUG_OBBS
//#define OBBTREE_GPU_COLLISION_DETECTION_DEBUG_TRIANGLES
//#define OBBTREE_GPU_COLLISION_DETECTION_DEBUG_TRANSFORMED_VERTICES

void ObbTreeGPUCollisionDetection::draw(const core::visual::VisualParams *vparams)
{
    BruteForceDetection::draw(vparams);

    //std::cout << " draw intersecting triangles: " << m_intersectingTriangles.size() << std::endl;
    //std::cout << " draw intersecting obbs     : " << m_intersectingOBBs.size() << std::endl;

#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG_OBBS
    if (m_intersectingOBBs.size() > 0)
    {
        for (std::map<std::string, std::vector<std::pair<int,int> > >::const_iterator it = m_intersectingOBBs.begin();
             it != m_intersectingOBBs.end(); it++)
        {
            std::string modelName1, modelName2;
            const std::string& modelPairId = it->first;

            //std::cout << " pair: " << modelPairId << std::endl;

            std::vector<std::string> v;
            boost::algorithm::iter_split(v, modelPairId, boost::algorithm::first_finder("::"));

            if (v.size() == 2)
            {
                modelName1 = v.at(0);
                modelName2 = v.at(1);

                ObbTreeGPUCollisionModel<Vec3Types>* model1 = m_obbModels[modelName1];
                ObbTreeGPUCollisionModel<Vec3Types>* model2 = m_obbModels[modelName2];

                //std::cout << " model1 ptr = " << model1 << ", model2 ptr = " << model2 << std::endl;
                if (model1 && model2)
                {
                    Vector3 model1Pos, model2Pos;
                    Matrix3 model1Ori, model2Ori;
                    model1->getPosition(model1Pos);
                    model2->getPosition(model2Pos);
                    model1->getOrientation(model1Ori);
                    model2->getOrientation(model2Ori);

                    Matrix4 model1Mat; model1Mat.identity();
                    Matrix4 model2Mat; model2Mat.identity();

                    for (short k = 0; k < 3; k++)
                    {
                        for (short l = 0; l < 3; l++)
                        {
                            model1Mat(k,l) = model1Ori(k,l);
                            model2Mat(k,l) = model2Ori(k,l);
                        }
                    }
                    std::vector<std::pair<int,int> >& overlappingOBBs = m_intersectingOBBs[modelPairId];

                    //std::cout << " model1 = " << modelName1 << ", model2 = " << modelName2 << "; pairs = " << overlappingOBBs.size() << std::endl;

                    glPushMatrix();
                    glPushAttrib(GL_ENABLE_BIT);
                    glEnable(GL_COLOR_MATERIAL);

                    for (std::vector<std::pair<int, int> >::const_iterator obb_it = overlappingOBBs.begin();
                         obb_it != overlappingOBBs.end(); obb_it++)
                    {
                        BV* obb1 = model1->getPqpModel()->child(obb_it->first);
                        BV* obb2 = model2->getPqpModel()->child(obb_it->second);

                        glTranslated(model1Pos.x(), model1Pos.y(), model1Pos.z());
                        glMultMatrixd(model1Mat.transposed().ptr());

                        glTranslated(obb1->To[0], obb1->To[1], obb1->To[2]);

                        Matrix4 obb1Ori; obb1Ori.identity();
                        for (short k = 0; k < 3; k++)
                            for (short l = 0; l < 3; l++)
                                obb1Ori(k,l) = obb1->R[k][l];

                        glMultMatrixd(obb1Ori.transposed().ptr());

                        Vec4f obbColor1(0,1,0,0.75);
                        if (obb1->Leaf())
                            obbColor1 = Vec4f(1,0,1,0.75f);

                        Vector3 obb1He(obb1->d[0],obb1->d[1],obb1->d[2]);
                        BVHDrawHelpers::drawCoordinateMarkerGL(0.5f, 0.25f);
                        BVHDrawHelpers::drawObbVolume(obb1He, obbColor1, true);

                        glMultMatrixd(obb1Ori.ptr());
                        glTranslated(-obb1->To[0], -obb1->To[1], -obb1->To[2]);
                        glMultMatrixd(model1Mat.ptr());
                        glTranslated(-model1Pos.x(), -model1Pos.y(), -model1Pos.z());

                        glTranslated(model2Pos.x(), model2Pos.y(), model2Pos.z());
                        glMultMatrixd(model2Mat.transposed().ptr());
                        glTranslated(obb2->To[0], obb2->To[1], obb2->To[2]);

                        Matrix4 obb2Ori; obb2Ori.identity();
                        for (short k = 0; k < 3; k++)
                            for (short l = 0; l < 3; l++)
                                obb2Ori(k,l) = obb2->R[k][l];

                        glMultMatrixd(obb2Ori.transposed().ptr());

                        Vec4f obbColor2(1,0,0,0.75);
                        if (obb2->Leaf())
                            obbColor2 = Vec4f(1,1,0,0.75f);

                        Vector3 obb2He(obb2->d[0],obb2->d[1],obb2->d[2]);
                        BVHDrawHelpers::drawCoordinateMarkerGL(0.5f, 0.25f);
                        BVHDrawHelpers::drawObbVolume(obb2He, obbColor2, true);

                        glMultMatrixd(obb2Ori.ptr());

                        glTranslated(-obb2->To[0], -obb2->To[1], -obb2->To[2]);
                        glMultMatrixd(model2Mat.ptr());
                        glTranslated(-model2Pos.x(), -model2Pos.y(), -model2Pos.z());
                    }
                    glPopAttrib();
                    glPopMatrix();
                }
            }
        }
    }
#endif
#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG_TRIANGLES
    if (m_intersectingTriangles.size() > 0)
    {

        for (std::map<std::string, std::vector<std::pair<int,int> > >::const_iterator it = m_intersectingTriangles.begin();
             it != m_intersectingTriangles.end(); it++)
        {
            std::string modelName1, modelName2;
            const std::string& modelPairId = it->first;

            std::vector<std::string> v;
            boost::algorithm::iter_split(v, modelPairId, boost::algorithm::first_finder("::"));

            //std::cout << " Draw for model pair: " << modelPairId << std::endl;
            if (v.size() == 2)
            {
                modelName1 = v.at(0);
                modelName2 = v.at(1);

                //std::cout << " model ids: " << modelName1 << "," << modelName2 << std::endl;

                ObbTreeGPUCollisionModel<Vec3Types> *obbModel1 = NULL, *obbModel2 = NULL;
                ObbTreeCPUCollisionModel<Vec3Types> *pqpModel1 = NULL, *pqpModel2 = NULL;
                std::vector<sofa::core::topology::Triangle> intersectingTriangles1, intersectingTriangles2;

                if (m_obbModels.find(modelName1) != m_obbModels.end() && m_obbModels.find(modelName2) != m_obbModels.end())
                {
                    obbModel1 = m_obbModels[modelName1];
                    obbModel2 = m_obbModels[modelName2];
                }
                else if (m_pqpModels.find(modelName1) != m_pqpModels.end() && m_pqpModels.find(modelName2) != m_pqpModels.end())
                {
                    pqpModel1 = m_pqpModels[modelName1];
                    pqpModel2 = m_pqpModels[modelName2];
                }

                {

                    // std::cout << " found both models in OBB Model instance register" << std::endl;

                    Vector3 modelPos1, modelPos2;
                    Matrix3 modelOrientation1, modelOrientation2;
                    Matrix4 modelOri1, modelOri2;
                    modelOri1.identity(); modelOri2.identity();

                    if (obbModel1 != NULL && obbModel2 != NULL)
                    {
                        obbModel1->getPosition(modelPos1);
                        obbModel2->getPosition(modelPos2);

                        obbModel1->getOrientation(modelOrientation1);
                        obbModel2->getOrientation(modelOrientation2);

                        for (int k = 0; k < 3; k++)
                        {
                            for (int l = 0; l < 3; l++)
                            {
                                modelOri1[k][l] = modelOrientation1[k][l];
                                modelOri2[k][l] = modelOrientation2[k][l];
                            }
                        }
                    }

#if 0
                    const sofa::core::objectmodel::BaseData* posData1 = NULL;
                    const sofa::core::objectmodel::BaseData* posData2 = NULL;
                    if (obbModel1 != NULL && obbModel2 != NULL)
                    {
                        posData1 = obbModel1->getMechanicalState()->baseRead(core::ConstVecCoordId::position());
                        posData2 = obbModel2->getMechanicalState()->baseRead(core::ConstVecCoordId::position());
                    }
                    else if (pqpModel1 != NULL && pqpModel2 != NULL)
                    {
                        posData1 = pqpModel1->getObjectMState()->baseRead(core::ConstVecCoordId::position());
                        posData2 = pqpModel2->getObjectMState()->baseRead(core::ConstVecCoordId::position());
                    }

                    if (posData1)
                    {
                        const void* posValues = posData1->getValueVoidPtr();
                        double t0 = posData1->getValueTypeInfo()->getScalarValue(posValues, 0);
                        double t1 = posData1->getValueTypeInfo()->getScalarValue(posValues, 1);
                        double t2 = posData1->getValueTypeInfo()->getScalarValue(posValues, 2);
                        double r0 = posData1->getValueTypeInfo()->getScalarValue(posValues, 3);
                        double r1 = posData1->getValueTypeInfo()->getScalarValue(posValues, 4);
                        double r2 = posData1->getValueTypeInfo()->getScalarValue(posValues, 5);
                        double r3 = posData1->getValueTypeInfo()->getScalarValue(posValues, 6);

                        modelPos1 = Vector3(t0, t1, t2);
                        Quaternion newRot = Quaternion(r0,r1,r2,r3);

                        Matrix3 newOrientation;
                        newRot.toMatrix(newOrientation);

                        for (int k = 0; k < 3; k++)
                        {
                            for (int l = 0; l < 3; l++)
                            {
                                modelOri1[k][l] = newOrientation[k][l];
                            }
                        }
                    }

                    if (posData2)
                    {
                        const void* posValues = posData2->getValueVoidPtr();
                        double t0 = posData2->getValueTypeInfo()->getScalarValue(posValues, 0);
                        double t1 = posData2->getValueTypeInfo()->getScalarValue(posValues, 1);
                        double t2 = posData2->getValueTypeInfo()->getScalarValue(posValues, 2);
                        double r0 = posData2->getValueTypeInfo()->getScalarValue(posValues, 3);
                        double r1 = posData2->getValueTypeInfo()->getScalarValue(posValues, 4);
                        double r2 = posData2->getValueTypeInfo()->getScalarValue(posValues, 5);
                        double r3 = posData2->getValueTypeInfo()->getScalarValue(posValues, 6);

                        modelPos2 = Vector3(t0, t1, t2);
                        Quaternion newRot = Quaternion(r0,r1,r2,r3);

                        Matrix3 newOrientation;
                        newRot.toMatrix(newOrientation);

                        for (int k = 0; k < 3; k++)
                        {
                            for (int l = 0; l < 3; l++)
                            {
                                modelOri2[k][l] = newOrientation[k][l];
                            }
                        }
                    }
#endif
                    const std::vector<std::pair<int,int> >& intersectingTris = it->second;
                    //std::cout << " intersecting triangle pairs recorded: " << intersectingTris.size() << std::endl;
                    for (std::vector<std::pair<int,int> >::const_iterator tri_it = intersectingTris.begin(); tri_it != intersectingTris.end(); tri_it++)
                    {
                        sofa::core::topology::Triangle tri1, tri2;
                        // std::cout << " * " << tri_it->first << ", " << tri_it->second << std::endl;
                        if (obbModel1 != NULL && obbModel1->getTriangle(tri_it->first, tri1) &&
                            obbModel2 != NULL && obbModel2->getTriangle(tri_it->second, tri2))
                        {
                            intersectingTriangles1.push_back(tri1);
                            intersectingTriangles2.push_back(tri2);
                        }

                        if (pqpModel1 != NULL && pqpModel1->getTriangle(tri_it->first, tri1) &&
                            pqpModel2 != NULL && pqpModel2->getTriangle(tri_it->second, tri2))
                        {
                            intersectingTriangles1.push_back(tri1);
                            intersectingTriangles2.push_back(tri2);
                        }
                    }

                    // std::cout << " model1 pos: " << modelPos1 << ", model2 pos: " << modelPos2 << std::endl;
                    // std::cout << " model1 ori: " << modelOri1 << ", model2 ori: " << modelOri2 << std::endl;
                    // std::cout << " triangles in model1: " << intersectingTriangles1.size() << ", in model2: " << intersectingTriangles2.size() << std::endl;
                    if (intersectingTriangles1.size() > 0 && intersectingTriangles2.size() > 0)
                    {

                        glPushMatrix();
                        glPushAttrib(GL_ENABLE_BIT);
                        glEnable(GL_COLOR_MATERIAL);

                        glBegin(GL_LINES);
                        glColor4d(1,1,1,1);
                        glVertex3d(0,0,0);
                        glColor4d(1,0,1,1);
                        glVertex3d(modelPos1.x(), modelPos1.y(), modelPos1.z());
                        glEnd();

                        glTranslated(modelPos1.x(), modelPos1.y(), modelPos1.z());
                        glMultMatrixd(modelOri1.transposed().ptr());

                        glLineWidth(8.0f);
                        glBegin(GL_LINES);
                        for (std::vector<sofa::core::topology::Triangle>::const_iterator it = intersectingTriangles1.begin(); it != intersectingTriangles1.end(); it++)
                        {
                            const sofa::core::topology::Triangle& tri = *it;
                            Vector3 vt1, vt2, vt3;

                            if (obbModel1 != NULL)
                            {
                                obbModel1->getVertex(tri[0], vt1);
                                obbModel1->getVertex(tri[1], vt2);
                                obbModel1->getVertex(tri[2], vt3);
                            }

                            if (pqpModel1 != NULL)
                            {
                                pqpModel1->getVertex(tri[0], vt1);
                                pqpModel1->getVertex(tri[1], vt2);
                                pqpModel1->getVertex(tri[2], vt3);
                            }

                            //std::cout << "   draw: " << tri << ": " << vt1 << ", " << vt2 << ", " << vt3 << std::endl;

                            glColor4d(0,1,0,1);
                            glVertex3d(vt1.x(), vt1.y(), vt1.z());
                            glColor4d(0,1,0,1);
                            glVertex3d(vt2.x(), vt2.y(), vt2.z());
                            glColor4d(0,1,0,1);
                            glVertex3d(vt2.x(), vt2.y(), vt2.z());
                            glColor4d(0,1,0,1);
                            glVertex3d(vt3.x(), vt3.y(), vt3.z());
                            glColor4d(0,1,0,1);
                            glVertex3d(vt3.x(), vt3.y(), vt3.z());
                            glColor4d(0,1,0,1);
                            glVertex3d(vt1.x(), vt1.y(), vt1.z());
                        }
                        glEnd();
                        glLineWidth(1.0f);

                        glPopAttrib();
                        glPopMatrix();

                        glPushMatrix();
                        glPushAttrib(GL_ENABLE_BIT);
                        glEnable(GL_COLOR_MATERIAL);

                        glBegin(GL_LINES);
                        glColor4d(1,1,1,1);
                        glVertex3d(0,0,0);
                        glColor4d(0,1,1,1);
                        glVertex3d(modelPos2.x(), modelPos2.y(), modelPos2.z());
                        glEnd();

                        glTranslated(modelPos2.x(), modelPos2.y(), modelPos2.z());
                        glMultMatrixd(modelOri2.transposed().ptr());

                        glLineWidth(8.0f);
                        glBegin(GL_LINES);
                        for (std::vector<sofa::core::topology::Triangle>::const_iterator it = intersectingTriangles2.begin(); it != intersectingTriangles2.end(); it++)
                        {
                            const sofa::core::topology::Triangle& tri = *it;
                            Vector3 vt1, vt2, vt3;

                            if (obbModel2 != NULL)
                            {
                                obbModel2->getVertex(tri[0], vt1);
                                obbModel2->getVertex(tri[1], vt2);
                                obbModel2->getVertex(tri[2], vt3);
                            }

                            if (pqpModel2 != NULL)
                            {
                                pqpModel2->getVertex(tri[0], vt1);
                                pqpModel2->getVertex(tri[1], vt2);
                                pqpModel2->getVertex(tri[2], vt3);
                            }

                            //std::cout << "   draw: " << tri << ": " << vt1 << ", " << vt2 << ", " << vt3 << std::endl;

                            glColor4d(1,1,1,1);
                            glVertex3d(vt1.x(), vt1.y(), vt1.z());
                            glColor4d(1,1,1,1);
                            glVertex3d(vt2.x(), vt2.y(), vt2.z());
                            glColor4d(1,1,1,1);
                            glVertex3d(vt2.x(), vt2.y(), vt2.z());
                            glColor4d(1,1,1,1);
                            glVertex3d(vt3.x(), vt3.y(), vt3.z());
                            glColor4d(1,1,1,1);
                            glVertex3d(vt3.x(), vt3.y(), vt3.z());
                            glColor4d(1,1,1,1);
                            glVertex3d(vt1.x(), vt1.y(), vt1.z());
                        }
                        glEnd();
                        glLineWidth(1.0f);

                        glPopAttrib();
                        glPopMatrix();
                    }
                }
            }
        }
    }
#endif

#ifdef OBBTREE_GPU_COLLISION_DETECTION_DEBUG_TRANSFORMED_VERTICES
    if (m_transformedVertices.size() > 0)
    {
        for (std::map<std::string, std::pair<GPUVertex*, GPUVertex*> >::iterator it = m_transformedVertices.begin(); it != m_transformedVertices.end(); it++)
        {
            GPUVertex* m1Vertices = it->second.first;
            GPUVertex* m2Vertices = it->second.second;

            std::string modelName1, modelName2;
            const std::string& modelPairId = it->first;

            std::vector<std::string> v;
            boost::algorithm::iter_split(v, modelPairId, boost::algorithm::first_finder("::"));

            //std::cout << " Draw for model pair: " << modelPairId << std::endl;
            if (v.size() == 2)
            {
                modelName1 = v.at(0);
                modelName2 = v.at(1);

                //std::cout << " model ids: " << modelName1 << "," << modelName2 << std::endl;

                ObbTreeGPUCollisionModel<Vec3Types> *obbModel1 = NULL, *obbModel2 = NULL;

                if (m_obbModels.find(modelName1) != m_obbModels.end() && m_obbModels.find(modelName2) != m_obbModels.end())
                {
                    obbModel1 = m_obbModels[modelName1];
                    obbModel2 = m_obbModels[modelName2];

                    glPointSize(5.0f);
                    glPushMatrix();
                    glPushAttrib(GL_ENABLE_BIT);
                    glEnable(GL_COLOR_MATERIAL);

                    std::cout << "model1 vertices: " << obbModel1->numVertices() << std::endl;
                    glBegin(GL_POINTS);
                    for (int i = 0; i < obbModel1->numVertices(); i++)
                    {
                        std::cout << " * " << i << ": " << m1Vertices[i].v.x << "," << m1Vertices[i].v.y << "," << m1Vertices[i].v.z << std::endl;
                        glColor4f(1,0,0,0.75);
                        glVertex3d(m1Vertices[i].v.x, m1Vertices[i].v.y, m1Vertices[i].v.z);
                    }
                    glEnd();

                    glPopAttrib();
                    glPopMatrix();

                    glPushMatrix();
                    glPushAttrib(GL_ENABLE_BIT);
                    glEnable(GL_COLOR_MATERIAL);

                    std::cout << "model2 vertices: " << obbModel2->numVertices() << std::endl;
                    glBegin(GL_POINTS);
                    for (int i = 0; i < obbModel2->numVertices(); i++)
                    {
                        std::cout << " * " << i << ": " << m2Vertices[i].v.x << "," << m2Vertices[i].v.y << "," << m2Vertices[i].v.z << std::endl;
                        glColor4f(1,1,0,0.75);
                        glVertex3d(m2Vertices[i].v.x, m2Vertices[i].v.y, m2Vertices[i].v.z);
                    }
                    glEnd();

                    glPopAttrib();
                    glPopMatrix();
                    glPointSize(1.0f);
                }
            }
        }
    }
#endif
}



/*if (freeBinsPerBinLevel[it->first] == 0)
                                        {
                                            if (summedResultSize_tmp > potentialResults && freeBinsPerBinLevel[it->first] >= 0)
                                            {
                                                std::cout << "   bins needed in level " << it->first << " = " << q << ", enough to fulfill size requirement = " << potentialResults << std::endl;

                                                std::cout << "    marking bins as _blocked" << std::endl;
                                                unsigned int freeBinsInSlot = 0, blockedBinsInSlot = 0;
                                                for (unsigned int r = 0; r < _streamedWorkerResults[it->first].size(); r++)
                                                {
                                                    if (_streamedWorkerResults[it->first][r]->_blocked == false)
                                                    {
                                                        freeBinsInSlot++;
                                                        std::cout << "     - bin " << r << " still free, marking as blocked" << std::endl;
                                                        claimedResultBinsPerPairCheck[it->first].insert(std::make_pair(m, q));
                                                        //_streamedWorkerResults[it->first][q]->_blocked = true;
                                                    }
                                                    else
                                                    {
                                                        blockedBinsInSlot++;
                                                        std::cout << "    - bin " << q << " already blocked, skipping" << std::endl;
                                                    }

                                                    if (freeBinsInSlot == freeBinsPerBinLevel[it->first])
                                                    {
                                                        std::cout << "   - found " << freeBinsInSlot << " slots to claim, stop search" << std::endl;
                                                        break;
                                                    }
                                                }

                                                if (freeBinsInSlot == freeBinsPerBinLevel[it->first])
                                                {
                                                    std::cout << "   Claiming remaining blocks: SUCCESS -- free slots blocked = " << freeBinsInSlot << ", already blocked = " << blockedBinsInSlot << std::endl;
                                                    std::cout << "     setting _blocked flags in target slots: "  << claimedResultBinsPerPairCheck[it->first].size() << " slots." << std::endl;

                                                    for (std::multimap<unsigned int, unsigned int>::const_iterator sit = claimedResultBinsPerPairCheck[it->first].begin(); sit != claimedResultBinsPerPairCheck[it->first].end(); sit++)
                                                    {
                                                        if (sit->first == m)
                                                        {
                                                            std::cout << "       - set slot " << sit->second << " to blocked" << std::endl;
                                                            _streamedWorkerResults[it->first][sit->second]->_blocked = true;

                                                            summedResultSize += _streamedWorkerResults[it->first][sit->second]->_maxResults;
                                                            std::cout << "         summedResultSize updated = " << summedResultSize << std::endl;

                                                            if (summedResultSize >= potentialResults)
                                                            {
                                                                fulfilledRequirements = true;
                                                                std::cout << "       found enough result bins to reserve; marking as requirements fulfilled!" << std::endl;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // fulfilledRequirements = false;
                                                    std::cout << "   Claiming remaining blocks: FAILURE -- free slots blocked = " << freeBinsInSlot << ", already blocked = " << blockedBinsInSlot << std::endl;
                                                    continue;
                                                }

                                                if (summedResultSize >= potentialResults)
                                                {
                                                    std::cout << "   summedResultSize = " << summedResultSize << " >= potentialResults = " << potentialResults << std::endl;
                                                    std::cout << "   tri-pair check HAS ENOUGH result bins reserved, marking als REQUIREMENTS FULFILLED!" << std::endl;
                                                    fulfilledRequirements = true;

                                                    freeBinsPerBinLevel[it->first] -= it->second;

                                                    break;
                                                }

                                                // summedResultSize += summedResultSize_tmp;
                                                break;
                                            }

                                            std::cout << "  claimed all remaining free bins in level " << it->first << std::endl;
                                            // summedResultSize += summedResultSize_tmp;
                                            std::cout << "  summedResultSize updated = " << summedResultSize << std::endl;
                                            break;
                                        }*/